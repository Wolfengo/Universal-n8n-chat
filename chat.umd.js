(function (ue, p) { typeof exports == "object" && typeof module < "u" ? p(exports, require("vue")) : typeof define == "function" && define.amd ? define(["exports", "vue"], p) : (ue = typeof globalThis < "u" ? globalThis : ue || self, p(ue.N8nChat = {}, ue.Vue)) })(this, function (ue, p) {
	"use strict"; function Pt(t) { return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t } function Sr(t) { if (t.__esModule) return t; var e = t.default; if (typeof e == "function") { var n = function r() { return this instanceof r ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments) }; n.prototype = e.prototype } else n = {}; return Object.defineProperty(n, "__esModule", { value: !0 }), Object.keys(t).forEach(function (r) { var o = Object.getOwnPropertyDescriptor(t, r); Object.defineProperty(n, r, o.get ? o : { enumerable: !0, get: function () { return t[r] } }) }), n } function zt(t) { return t instanceof Map ? t.clear = t.delete = t.set = function () { throw new Error("map is read-only") } : t instanceof Set && (t.add = t.clear = t.delete = function () { throw new Error("set is read-only") }), Object.freeze(t), Object.getOwnPropertyNames(t).forEach(e => { const n = t[e], r = typeof n; (r === "object" || r === "function") && !Object.isFrozen(n) && zt(n) }), t } class Ut { constructor(e) { e.data === void 0 && (e.data = {}), this.data = e.data, this.isMatchIgnored = !1 } ignoreMatch() { this.isMatchIgnored = !0 } } function Vt(t) { return t.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;") } function ae(t, ...e) { const n = Object.create(null); for (const r in t) n[r] = t[r]; return e.forEach(function (r) { for (const o in r) n[o] = r[o] }), n } const Dr = "</span>", $t = t => !!t.scope, Tr = (t, { prefix: e }) => { if (t.startsWith("language:")) return t.replace("language:", "language-"); if (t.includes(".")) { const n = t.split("."); return [`${e}${n.shift()}`, ...n.map((r, o) => `${r}${"_".repeat(o + 1)}`)].join(" ") } return `${e}${t}` }; class Rr { constructor(e, n) { this.buffer = "", this.classPrefix = n.classPrefix, e.walk(this) } addText(e) { this.buffer += Vt(e) } openNode(e) { if (!$t(e)) return; const n = Tr(e.scope, { prefix: this.classPrefix }); this.span(n) } closeNode(e) { $t(e) && (this.buffer += Dr) } value() { return this.buffer } span(e) { this.buffer += `<span class="${e}">` } } const Gt = (t = {}) => { const e = { children: [] }; return Object.assign(e, t), e }; class nt { constructor() { this.rootNode = Gt(), this.stack = [this.rootNode] } get top() { return this.stack[this.stack.length - 1] } get root() { return this.rootNode } add(e) { this.top.children.push(e) } openNode(e) { const n = Gt({ scope: e }); this.add(n), this.stack.push(n) } closeNode() { if (this.stack.length > 1) return this.stack.pop() } closeAllNodes() { for (; this.closeNode();); } toJSON() { return JSON.stringify(this.rootNode, null, 4) } walk(e) { return this.constructor._walk(e, this.rootNode) } static _walk(e, n) { return typeof n == "string" ? e.addText(n) : n.children && (e.openNode(n), n.children.forEach(r => this._walk(e, r)), e.closeNode(n)), e } static _collapse(e) { typeof e != "string" && e.children && (e.children.every(n => typeof n == "string") ? e.children = [e.children.join("")] : e.children.forEach(n => { nt._collapse(n) })) } } class Nr extends nt { constructor(e) { super(), this.options = e } addText(e) { e !== "" && this.add(e) } startScope(e) { this.openNode(e) } endScope() { this.closeNode() } __addSublanguage(e, n) { const r = e.root; n && (r.scope = `language:${n}`), this.add(r) } toHTML() { return new Rr(this, this.options).value() } finalize() { return this.closeAllNodes(), !0 } } function Ae(t) { return t ? typeof t == "string" ? t : t.source : null } function Ht(t) { return pe("(?=", t, ")") } function Lr(t) { return pe("(?:", t, ")*") } function Br(t) { return pe("(?:", t, ")?") } function pe(...t) { return t.map(n => Ae(n)).join("") } function Mr(t) { const e = t[t.length - 1]; return typeof e == "object" && e.constructor === Object ? (t.splice(t.length - 1, 1), e) : {} } function rt(...t) { return "(" + (Mr(t).capture ? "" : "?:") + t.map(r => Ae(r)).join("|") + ")" } function jt(t) { return new RegExp(t.toString() + "|").exec("").length - 1 } function Ir(t, e) { const n = t && t.exec(e); return n && n.index === 0 } const Or = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./; function ot(t, { joinWith: e }) { let n = 0; return t.map(r => { n += 1; const o = n; let s = Ae(r), i = ""; for (; s.length > 0;) { const c = Or.exec(s); if (!c) { i += s; break } i += s.substring(0, c.index), s = s.substring(c.index + c[0].length), c[0][0] === "\\" && c[1] ? i += "\\" + String(Number(c[1]) + o) : (i += c[0], c[0] === "(" && n++) } return i }).map(r => `(${r})`).join(e) } const Fr = /\b\B/, Zt = "[a-zA-Z]\\w*", st = "[a-zA-Z_]\\w*", Wt = "\\b\\d+(\\.\\d+)?", Kt = "(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)", Jt = "\\b(0b[01]+)", Pr = "!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~", zr = (t = {}) => { const e = /^#![ ]*\//; return t.binary && (t.begin = pe(e, /.*\b/, t.binary, /\b.*/)), ae({ scope: "meta", begin: e, end: /$/, relevance: 0, "on:begin": (n, r) => { n.index !== 0 && r.ignoreMatch() } }, t) }, Ce = { begin: "\\\\[\\s\\S]", relevance: 0 }, Ur = { scope: "string", begin: "'", end: "'", illegal: "\\n", contains: [Ce] }, Vr = { scope: "string", begin: '"', end: '"', illegal: "\\n", contains: [Ce] }, $r = { begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/ }, Le = function (t, e, n = {}) { const r = ae({ scope: "comment", begin: t, end: e, contains: [] }, n); r.contains.push({ scope: "doctag", begin: "[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)", end: /(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/, excludeBegin: !0, relevance: 0 }); const o = rt("I", "a", "is", "so", "us", "to", "at", "if", "in", "it", "on", /[A-Za-z]+['](d|ve|re|ll|t|s|n)/, /[A-Za-z]+[-][a-z]+/, /[A-Za-z][a-z]{2,}/); return r.contains.push({ begin: pe(/[ ]+/, "(", o, /[.]?[:]?([.][ ]|[ ])/, "){3}") }), r }, Gr = Le("//", "$"), Hr = Le("/\\*", "\\*/"), jr = Le("#", "$"), Zr = { scope: "number", begin: Wt, relevance: 0 }, Wr = { scope: "number", begin: Kt, relevance: 0 }, Kr = { scope: "number", begin: Jt, relevance: 0 }, Jr = { scope: "regexp", begin: /\/(?=[^/\n]*\/)/, end: /\/[gimuy]*/, contains: [Ce, { begin: /\[/, end: /\]/, relevance: 0, contains: [Ce] }] }, Yr = { scope: "title", begin: Zt, relevance: 0 }, Xr = { scope: "title", begin: st, relevance: 0 }, Qr = { begin: "\\.\\s*" + st, relevance: 0 }; var Be = Object.freeze({ __proto__: null, APOS_STRING_MODE: Ur, BACKSLASH_ESCAPE: Ce, BINARY_NUMBER_MODE: Kr, BINARY_NUMBER_RE: Jt, COMMENT: Le, C_BLOCK_COMMENT_MODE: Hr, C_LINE_COMMENT_MODE: Gr, C_NUMBER_MODE: Wr, C_NUMBER_RE: Kt, END_SAME_AS_BEGIN: function (t) { return Object.assign(t, { "on:begin": (e, n) => { n.data._beginMatch = e[1] }, "on:end": (e, n) => { n.data._beginMatch !== e[1] && n.ignoreMatch() } }) }, HASH_COMMENT_MODE: jr, IDENT_RE: Zt, MATCH_NOTHING_RE: Fr, METHOD_GUARD: Qr, NUMBER_MODE: Zr, NUMBER_RE: Wt, PHRASAL_WORDS_MODE: $r, QUOTE_STRING_MODE: Vr, REGEXP_MODE: Jr, RE_STARTERS_RE: Pr, SHEBANG: zr, TITLE_MODE: Yr, UNDERSCORE_IDENT_RE: st, UNDERSCORE_TITLE_MODE: Xr }); function eo(t, e) { t.input[t.index - 1] === "." && e.ignoreMatch() } function to(t, e) { t.className !== void 0 && (t.scope = t.className, delete t.className) } function no(t, e) { e && t.beginKeywords && (t.begin = "\\b(" + t.beginKeywords.split(" ").join("|") + ")(?!\\.)(?=\\b|\\s)", t.__beforeBegin = eo, t.keywords = t.keywords || t.beginKeywords, delete t.beginKeywords, t.relevance === void 0 && (t.relevance = 0)) } function ro(t, e) { Array.isArray(t.illegal) && (t.illegal = rt(...t.illegal)) } function oo(t, e) { if (t.match) { if (t.begin || t.end) throw new Error("begin & end are not supported with match"); t.begin = t.match, delete t.match } } function so(t, e) { t.relevance === void 0 && (t.relevance = 1) } const co = (t, e) => { if (!t.beforeMatch) return; if (t.starts) throw new Error("beforeMatch cannot be used with starts"); const n = Object.assign({}, t); Object.keys(t).forEach(r => { delete t[r] }), t.keywords = n.keywords, t.begin = pe(n.beforeMatch, Ht(n.begin)), t.starts = { relevance: 0, contains: [Object.assign(n, { endsParent: !0 })] }, t.relevance = 0, delete n.beforeMatch }, io = ["of", "and", "for", "in", "not", "or", "if", "then", "parent", "list", "value"], ao = "keyword"; function Yt(t, e, n = ao) { const r = Object.create(null); return typeof t == "string" ? o(n, t.split(" ")) : Array.isArray(t) ? o(n, t) : Object.keys(t).forEach(function (s) { Object.assign(r, Yt(t[s], e, s)) }), r; function o(s, i) { e && (i = i.map(c => c.toLowerCase())), i.forEach(function (c) { const a = c.split("|"); r[a[0]] = [s, lo(a[0], a[1])] }) } } function lo(t, e) { return e ? Number(e) : uo(t) ? 0 : 1 } function uo(t) { return io.includes(t.toLowerCase()) } const Xt = {}, fe = t => { console.error(t) }, Qt = (t, ...e) => { console.log(`WARN: ${t}`, ...e) }, _e = (t, e) => { Xt[`${t}/${e}`] || (console.log(`Deprecated as of ${t}. ${e}`), Xt[`${t}/${e}`] = !0) }, Me = new Error; function en(t, e, { key: n }) { let r = 0; const o = t[n], s = {}, i = {}; for (let c = 1; c <= e.length; c++)i[c + r] = o[c], s[c + r] = !0, r += jt(e[c - 1]); t[n] = i, t[n]._emit = s, t[n]._multi = !0 } function po(t) { if (Array.isArray(t.begin)) { if (t.skip || t.excludeBegin || t.returnBegin) throw fe("skip, excludeBegin, returnBegin not compatible with beginScope: {}"), Me; if (typeof t.beginScope != "object" || t.beginScope === null) throw fe("beginScope must be object"), Me; en(t, t.begin, { key: "beginScope" }), t.begin = ot(t.begin, { joinWith: "" }) } } function fo(t) { if (Array.isArray(t.end)) { if (t.skip || t.excludeEnd || t.returnEnd) throw fe("skip, excludeEnd, returnEnd not compatible with endScope: {}"), Me; if (typeof t.endScope != "object" || t.endScope === null) throw fe("endScope must be object"), Me; en(t, t.end, { key: "endScope" }), t.end = ot(t.end, { joinWith: "" }) } } function ho(t) { t.scope && typeof t.scope == "object" && t.scope !== null && (t.beginScope = t.scope, delete t.scope) } function go(t) { ho(t), typeof t.beginScope == "string" && (t.beginScope = { _wrap: t.beginScope }), typeof t.endScope == "string" && (t.endScope = { _wrap: t.endScope }), po(t), fo(t) } function mo(t) { function e(i, c) { return new RegExp(Ae(i), "m" + (t.case_insensitive ? "i" : "") + (t.unicodeRegex ? "u" : "") + (c ? "g" : "")) } class n { constructor() { this.matchIndexes = {}, this.regexes = [], this.matchAt = 1, this.position = 0 } addRule(c, a) { a.position = this.position++, this.matchIndexes[this.matchAt] = a, this.regexes.push([a, c]), this.matchAt += jt(c) + 1 } compile() { this.regexes.length === 0 && (this.exec = () => null); const c = this.regexes.map(a => a[1]); this.matcherRe = e(ot(c, { joinWith: "|" }), !0), this.lastIndex = 0 } exec(c) { this.matcherRe.lastIndex = this.lastIndex; const a = this.matcherRe.exec(c); if (!a) return null; const l = a.findIndex((d, f) => f > 0 && d !== void 0), u = this.matchIndexes[l]; return a.splice(0, l), Object.assign(a, u) } } class r { constructor() { this.rules = [], this.multiRegexes = [], this.count = 0, this.lastIndex = 0, this.regexIndex = 0 } getMatcher(c) { if (this.multiRegexes[c]) return this.multiRegexes[c]; const a = new n; return this.rules.slice(c).forEach(([l, u]) => a.addRule(l, u)), a.compile(), this.multiRegexes[c] = a, a } resumingScanAtSamePosition() { return this.regexIndex !== 0 } considerAll() { this.regexIndex = 0 } addRule(c, a) { this.rules.push([c, a]), a.type === "begin" && this.count++ } exec(c) { const a = this.getMatcher(this.regexIndex); a.lastIndex = this.lastIndex; let l = a.exec(c); if (this.resumingScanAtSamePosition() && !(l && l.index === this.lastIndex)) { const u = this.getMatcher(0); u.lastIndex = this.lastIndex + 1, l = u.exec(c) } return l && (this.regexIndex += l.position + 1, this.regexIndex === this.count && this.considerAll()), l } } function o(i) { const c = new r; return i.contains.forEach(a => c.addRule(a.begin, { rule: a, type: "begin" })), i.terminatorEnd && c.addRule(i.terminatorEnd, { type: "end" }), i.illegal && c.addRule(i.illegal, { type: "illegal" }), c } function s(i, c) { const a = i; if (i.isCompiled) return a;[to, oo, go, co].forEach(u => u(i, c)), t.compilerExtensions.forEach(u => u(i, c)), i.__beforeBegin = null, [no, ro, so].forEach(u => u(i, c)), i.isCompiled = !0; let l = null; return typeof i.keywords == "object" && i.keywords.$pattern && (i.keywords = Object.assign({}, i.keywords), l = i.keywords.$pattern, delete i.keywords.$pattern), l = l || /\w+/, i.keywords && (i.keywords = Yt(i.keywords, t.case_insensitive)), a.keywordPatternRe = e(l, !0), c && (i.begin || (i.begin = /\B|\b/), a.beginRe = e(a.begin), !i.end && !i.endsWithParent && (i.end = /\B|\b/), i.end && (a.endRe = e(a.end)), a.terminatorEnd = Ae(a.end) || "", i.endsWithParent && c.terminatorEnd && (a.terminatorEnd += (i.end ? "|" : "") + c.terminatorEnd)), i.illegal && (a.illegalRe = e(i.illegal)), i.contains || (i.contains = []), i.contains = [].concat(...i.contains.map(function (u) { return bo(u === "self" ? i : u) })), i.contains.forEach(function (u) { s(u, a) }), i.starts && s(i.starts, c), a.matcher = o(a), a } if (t.compilerExtensions || (t.compilerExtensions = []), t.contains && t.contains.includes("self")) throw new Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation."); return t.classNameAliases = ae(t.classNameAliases || {}), s(t) } function tn(t) { return t ? t.endsWithParent || tn(t.starts) : !1 } function bo(t) { return t.variants && !t.cachedVariants && (t.cachedVariants = t.variants.map(function (e) { return ae(t, { variants: null }, e) })), t.cachedVariants ? t.cachedVariants : tn(t) ? ae(t, { starts: t.starts ? ae(t.starts) : null }) : Object.isFrozen(t) ? ae(t) : t } var _o = "11.9.0"; class ko extends Error { constructor(e, n) { super(e), this.name = "HTMLInjectionError", this.html = n } } const ct = Vt, nn = ae, rn = Symbol("nomatch"), xo = 7, on = function (t) {
		const e = Object.create(null), n = Object.create(null), r = []; let o = !0; const s = "Could not find the language '{}', did you forget to load/include a language module?", i = { disableAutodetect: !0, name: "Plain text", contains: [] }; let c = { ignoreUnescapedHTML: !1, throwUnescapedHTML: !1, noHighlightRe: /^(no-?highlight)$/i, languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i, classPrefix: "hljs-", cssSelector: "pre code", languages: null, __emitter: Nr }; function a(g) { return c.noHighlightRe.test(g) } function l(g) { let y = g.className + " "; y += g.parentNode ? g.parentNode.className : ""; const D = c.languageDetectRe.exec(y); if (D) { const M = G(D[1]); return M || (Qt(s.replace("{}", D[1])), Qt("Falling back to no-highlight mode for this block.", g)), M ? D[1] : "no-highlight" } return y.split(/\s+/).find(M => a(M) || G(M)) } function u(g, y, D) {
			let M = "", V = ""; typeof y == "object" ? (M = g, D = y.ignoreIllegals, V = y.language) : (_e("10.7.0", "highlight(lang, code, ...args) has been deprecated."), _e("10.7.0", `Please use highlight(code, options) instead.
https://github.com/highlightjs/highlight.js/issues/2277`), V = g, M = y), D === void 0 && (D = !0); const Z = { code: M, language: V }; O("before:highlight", Z); const X = Z.result ? Z.result : d(Z.language, Z.code, D); return X.code = Z.code, O("after:highlight", X), X
		} function d(g, y, D, M) { const V = Object.create(null); function Z(w, A) { return w.keywords[A] } function X() { if (!S.keywords) { H.addText(z); return } let w = 0; S.keywordPatternRe.lastIndex = 0; let A = S.keywordPatternRe.exec(z), R = ""; for (; A;) { R += z.substring(w, A.index); const F = se.case_insensitive ? A[0].toLowerCase() : A[0], j = Z(S, F); if (j) { const [ie, ka] = j; if (H.addText(R), R = "", V[F] = (V[F] || 0) + 1, V[F] <= xo && (tt += ka), ie.startsWith("_")) R += A[0]; else { const xa = se.classNameAliases[ie] || ie; oe(A[0], xa) } } else R += A[0]; w = S.keywordPatternRe.lastIndex, A = S.keywordPatternRe.exec(z) } R += z.substring(w), H.addText(R) } function Qe() { if (z === "") return; let w = null; if (typeof S.subLanguage == "string") { if (!e[S.subLanguage]) { H.addText(z); return } w = d(S.subLanguage, z, !0, qr[S.subLanguage]), qr[S.subLanguage] = w._top } else w = h(z, S.subLanguage.length ? S.subLanguage : null); S.relevance > 0 && (tt += w.relevance), H.__addSublanguage(w._emitter, w.language) } function W() { S.subLanguage != null ? Qe() : X(), z = "" } function oe(w, A) { w !== "" && (H.startScope(A), H.addText(w), H.endScope()) } function vr(w, A) { let R = 1; const F = A.length - 1; for (; R <= F;) { if (!w._emit[R]) { R++; continue } const j = se.classNameAliases[w[R]] || w[R], ie = A[R]; j ? oe(ie, j) : (z = ie, X(), z = ""), R++ } } function Er(w, A) { return w.scope && typeof w.scope == "string" && H.openNode(se.classNameAliases[w.scope] || w.scope), w.beginScope && (w.beginScope._wrap ? (oe(z, se.classNameAliases[w.beginScope._wrap] || w.beginScope._wrap), z = "") : w.beginScope._multi && (vr(w.beginScope, A), z = "")), S = Object.create(w, { parent: { value: S } }), S } function Ar(w, A, R) { let F = Ir(w.endRe, R); if (F) { if (w["on:end"]) { const j = new Ut(w); w["on:end"](A, j), j.isMatchIgnored && (F = !1) } if (F) { for (; w.endsParent && w.parent;)w = w.parent; return w } } if (w.endsWithParent) return Ar(w.parent, A, R) } function da(w) { return S.matcher.regexIndex === 0 ? (z += w[0], 1) : (Ft = !0, 0) } function ga(w) { const A = w[0], R = w.rule, F = new Ut(R), j = [R.__beforeBegin, R["on:begin"]]; for (const ie of j) if (ie && (ie(w, F), F.isMatchIgnored)) return da(A); return R.skip ? z += A : (R.excludeBegin && (z += A), W(), !R.returnBegin && !R.excludeBegin && (z = A)), Er(R, w), R.returnBegin ? 0 : A.length } function ma(w) { const A = w[0], R = y.substring(w.index), F = Ar(S, w, R); if (!F) return rn; const j = S; S.endScope && S.endScope._wrap ? (W(), oe(A, S.endScope._wrap)) : S.endScope && S.endScope._multi ? (W(), vr(S.endScope, w)) : j.skip ? z += A : (j.returnEnd || j.excludeEnd || (z += A), W(), j.excludeEnd && (z = A)); do S.scope && H.closeNode(), !S.skip && !S.subLanguage && (tt += S.relevance), S = S.parent; while (S !== F.parent); return F.starts && Er(F.starts, w), j.returnEnd ? 0 : A.length } function ba() { const w = []; for (let A = S; A !== se; A = A.parent)A.scope && w.unshift(A.scope); w.forEach(A => H.openNode(A)) } let et = {}; function Cr(w, A) { const R = A && A[0]; if (z += w, R == null) return W(), 0; if (et.type === "begin" && A.type === "end" && et.index === A.index && R === "") { if (z += y.slice(A.index, A.index + 1), !o) { const F = new Error(`0 width match regex (${g})`); throw F.languageName = g, F.badRule = et.rule, F } return 1 } if (et = A, A.type === "begin") return ga(A); if (A.type === "illegal" && !D) { const F = new Error('Illegal lexeme "' + R + '" for mode "' + (S.scope || "<unnamed>") + '"'); throw F.mode = S, F } else if (A.type === "end") { const F = ma(A); if (F !== rn) return F } if (A.type === "illegal" && R === "") return 1; if (Ot > 1e5 && Ot > A.index * 3) throw new Error("potential infinite loop, way more iterations than matches"); return z += R, R.length } const se = G(g); if (!se) throw fe(s.replace("{}", g)), new Error('Unknown language: "' + g + '"'); const _a = mo(se); let It = "", S = M || _a; const qr = {}, H = new c.__emitter(c); ba(); let z = "", tt = 0, be = 0, Ot = 0, Ft = !1; try { if (se.__emitTokens) se.__emitTokens(y, H); else { for (S.matcher.considerAll(); ;) { Ot++, Ft ? Ft = !1 : S.matcher.considerAll(), S.matcher.lastIndex = be; const w = S.matcher.exec(y); if (!w) break; const A = y.substring(be, w.index), R = Cr(A, w); be = w.index + R } Cr(y.substring(be)) } return H.finalize(), It = H.toHTML(), { language: g, value: It, relevance: tt, illegal: !1, _emitter: H, _top: S } } catch (w) { if (w.message && w.message.includes("Illegal")) return { language: g, value: ct(y), illegal: !0, relevance: 0, _illegalBy: { message: w.message, index: be, context: y.slice(be - 100, be + 100), mode: w.mode, resultSoFar: It }, _emitter: H }; if (o) return { language: g, value: ct(y), illegal: !1, relevance: 0, errorRaised: w, _emitter: H, _top: S }; throw w } } function f(g) { const y = { value: ct(g), illegal: !1, relevance: 0, _top: i, _emitter: new c.__emitter(c) }; return y._emitter.addText(g), y } function h(g, y) { y = y || c.languages || Object.keys(e); const D = f(g), M = y.filter(G).filter(P).map(W => d(W, g, !1)); M.unshift(D); const V = M.sort((W, oe) => { if (W.relevance !== oe.relevance) return oe.relevance - W.relevance; if (W.language && oe.language) { if (G(W.language).supersetOf === oe.language) return 1; if (G(oe.language).supersetOf === W.language) return -1 } return 0 }), [Z, X] = V, Qe = Z; return Qe.secondBest = X, Qe } function m(g, y, D) { const M = y && n[y] || D; g.classList.add("hljs"), g.classList.add(`language-${M}`) } function x(g) { let y = null; const D = l(g); if (a(D)) return; if (O("before:highlightElement", { el: g, language: D }), g.dataset.highlighted) { console.log("Element previously highlighted. To highlight again, first unset `dataset.highlighted`.", g); return } if (g.children.length > 0 && (c.ignoreUnescapedHTML || (console.warn("One of your code blocks includes unescaped HTML. This is a potentially serious security risk."), console.warn("https://github.com/highlightjs/highlight.js/wiki/security"), console.warn("The element with unescaped HTML:"), console.warn(g)), c.throwUnescapedHTML)) throw new ko("One of your code blocks includes unescaped HTML.", g.innerHTML); y = g; const M = y.textContent, V = D ? u(M, { language: D, ignoreIllegals: !0 }) : h(M); g.innerHTML = V.value, g.dataset.highlighted = "yes", m(g, D, V.language), g.result = { language: V.language, re: V.relevance, relevance: V.relevance }, V.secondBest && (g.secondBest = { language: V.secondBest.language, relevance: V.secondBest.relevance }), O("after:highlightElement", { el: g, result: V, text: M }) } function C(g) { c = nn(c, g) } const v = () => { q(), _e("10.6.0", "initHighlighting() deprecated.  Use highlightAll() now.") }; function b() { q(), _e("10.6.0", "initHighlightingOnLoad() deprecated.  Use highlightAll() now.") } let E = !1; function q() { if (document.readyState === "loading") { E = !0; return } document.querySelectorAll(c.cssSelector).forEach(x) } function T() { E && q() } typeof window < "u" && window.addEventListener && window.addEventListener("DOMContentLoaded", T, !1); function k(g, y) { let D = null; try { D = y(t) } catch (M) { if (fe("Language definition for '{}' could not be registered.".replace("{}", g)), o) fe(M); else throw M; D = i } D.name || (D.name = g), e[g] = D, D.rawDefinition = y.bind(null, t), D.aliases && N(D.aliases, { languageName: g }) } function B(g) { delete e[g]; for (const y of Object.keys(n)) n[y] === g && delete n[y] } function U() { return Object.keys(e) } function G(g) { return g = (g || "").toLowerCase(), e[g] || e[n[g]] } function N(g, { languageName: y }) { typeof g == "string" && (g = [g]), g.forEach(D => { n[D.toLowerCase()] = y }) } function P(g) { const y = G(g); return y && !y.disableAutodetect } function ce(g) { g["before:highlightBlock"] && !g["before:highlightElement"] && (g["before:highlightElement"] = y => { g["before:highlightBlock"](Object.assign({ block: y.el }, y)) }), g["after:highlightBlock"] && !g["after:highlightElement"] && (g["after:highlightElement"] = y => { g["after:highlightBlock"](Object.assign({ block: y.el }, y)) }) } function re(g) { ce(g), r.push(g) } function _(g) { const y = r.indexOf(g); y !== -1 && r.splice(y, 1) } function O(g, y) { const D = g; r.forEach(function (M) { M[D] && M[D](y) }) } function L(g) { return _e("10.7.0", "highlightBlock will be removed entirely in v12.0"), _e("10.7.0", "Please use highlightElement now."), x(g) } Object.assign(t, { highlight: u, highlightAuto: h, highlightAll: q, highlightElement: x, highlightBlock: L, configure: C, initHighlighting: v, initHighlightingOnLoad: b, registerLanguage: k, unregisterLanguage: B, listLanguages: U, getLanguage: G, registerAliases: N, autoDetection: P, inherit: nn, addPlugin: re, removePlugin: _ }), t.debugMode = function () { o = !1 }, t.safeMode = function () { o = !0 }, t.versionString = _o, t.regex = { concat: pe, lookahead: Ht, either: rt, optional: Br, anyNumberOfTimes: Lr }; for (const g in Be) typeof Be[g] == "object" && zt(Be[g]); return Object.assign(t, Be), t
	}, ke = on({}); ke.newInstance = () => on({}); var wo = ke; ke.HighlightJS = ke, ke.default = ke; const Ie = Pt(wo); function yo(t) { const e = t.regex, n = e.concat(/[\p{L}_]/u, e.optional(/[\p{L}0-9_.-]*:/u), /[\p{L}0-9_.-]*/u), r = /[\p{L}0-9._:-]+/u, o = { className: "symbol", begin: /&[a-z]+;|&#[0-9]+;|&#x[a-f0-9]+;/ }, s = { begin: /\s/, contains: [{ className: "keyword", begin: /#?[a-z_][a-z1-9_-]+/, illegal: /\n/ }] }, i = t.inherit(s, { begin: /\(/, end: /\)/ }), c = t.inherit(t.APOS_STRING_MODE, { className: "string" }), a = t.inherit(t.QUOTE_STRING_MODE, { className: "string" }), l = { endsWithParent: !0, illegal: /</, relevance: 0, contains: [{ className: "attr", begin: r, relevance: 0 }, { begin: /=\s*/, relevance: 0, contains: [{ className: "string", endsParent: !0, variants: [{ begin: /"/, end: /"/, contains: [o] }, { begin: /'/, end: /'/, contains: [o] }, { begin: /[^\s"'=<>`]+/ }] }] }] }; return { name: "HTML, XML", aliases: ["html", "xhtml", "rss", "atom", "xjb", "xsd", "xsl", "plist", "wsf", "svg"], case_insensitive: !0, unicodeRegex: !0, contains: [{ className: "meta", begin: /<![a-z]/, end: />/, relevance: 10, contains: [s, a, c, i, { begin: /\[/, end: /\]/, contains: [{ className: "meta", begin: /<![a-z]/, end: />/, contains: [s, i, a, c] }] }] }, t.COMMENT(/<!--/, /-->/, { relevance: 10 }), { begin: /<!\[CDATA\[/, end: /\]\]>/, relevance: 10 }, o, { className: "meta", end: /\?>/, variants: [{ begin: /<\?xml/, relevance: 10, contains: [a] }, { begin: /<\?[a-z][a-z0-9]+/ }] }, { className: "tag", begin: /<style(?=\s|>)/, end: />/, keywords: { name: "style" }, contains: [l], starts: { end: /<\/style>/, returnEnd: !0, subLanguage: ["css", "xml"] } }, { className: "tag", begin: /<script(?=\s|>)/, end: />/, keywords: { name: "script" }, contains: [l], starts: { end: /<\/script>/, returnEnd: !0, subLanguage: ["javascript", "handlebars", "xml"] } }, { className: "tag", begin: /<>|<\/>/ }, { className: "tag", begin: e.concat(/</, e.lookahead(e.concat(n, e.either(/\/>/, />/, /\s/)))), end: /\/?>/, contains: [{ className: "name", begin: n, relevance: 0, starts: l }] }, { className: "tag", begin: e.concat(/<\//, e.lookahead(e.concat(n, />/))), contains: [{ className: "name", begin: n, relevance: 0 }, { begin: />/, relevance: 0, endsParent: !0 }] }] } } const sn = "[A-Za-z$_][0-9A-Za-z$_]*", vo = ["as", "in", "of", "if", "for", "while", "finally", "var", "new", "function", "do", "return", "void", "else", "break", "catch", "instanceof", "with", "throw", "case", "default", "try", "switch", "continue", "typeof", "delete", "let", "yield", "const", "class", "debugger", "async", "await", "static", "import", "from", "export", "extends"], Eo = ["true", "false", "null", "undefined", "NaN", "Infinity"], cn = ["Object", "Function", "Boolean", "Symbol", "Math", "Date", "Number", "BigInt", "String", "RegExp", "Array", "Float32Array", "Float64Array", "Int8Array", "Uint8Array", "Uint8ClampedArray", "Int16Array", "Int32Array", "Uint16Array", "Uint32Array", "BigInt64Array", "BigUint64Array", "Set", "Map", "WeakSet", "WeakMap", "ArrayBuffer", "SharedArrayBuffer", "Atomics", "DataView", "JSON", "Promise", "Generator", "GeneratorFunction", "AsyncFunction", "Reflect", "Proxy", "Intl", "WebAssembly"], an = ["Error", "EvalError", "InternalError", "RangeError", "ReferenceError", "SyntaxError", "TypeError", "URIError"], ln = ["setInterval", "setTimeout", "clearInterval", "clearTimeout", "require", "exports", "eval", "isFinite", "isNaN", "parseFloat", "parseInt", "decodeURI", "decodeURIComponent", "encodeURI", "encodeURIComponent", "escape", "unescape"], Ao = ["arguments", "this", "super", "console", "window", "document", "localStorage", "sessionStorage", "module", "global"], Co = [].concat(ln, cn, an); function qo(t) { const e = t.regex, n = (y, { after: D }) => { const M = "</" + y[0].slice(1); return y.input.indexOf(M, D) !== -1 }, r = sn, o = { begin: "<>", end: "</>" }, s = /<[A-Za-z0-9\\._:-]+\s*\/>/, i = { begin: /<[A-Za-z0-9\\._:-]+/, end: /\/[A-Za-z0-9\\._:-]+>|\/>/, isTrulyOpeningTag: (y, D) => { const M = y[0].length + y.index, V = y.input[M]; if (V === "<" || V === ",") { D.ignoreMatch(); return } V === ">" && (n(y, { after: M }) || D.ignoreMatch()); let Z; const X = y.input.substring(M); if (Z = X.match(/^\s*=/)) { D.ignoreMatch(); return } if ((Z = X.match(/^\s+extends\s+/)) && Z.index === 0) { D.ignoreMatch(); return } } }, c = { $pattern: sn, keyword: vo, literal: Eo, built_in: Co, "variable.language": Ao }, a = "[0-9](_?[0-9])*", l = `\\.(${a})`, u = "0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*", d = { className: "number", variants: [{ begin: `(\\b(${u})((${l})|\\.)?|(${l}))[eE][+-]?(${a})\\b` }, { begin: `\\b(${u})\\b((${l})\\b|\\.)?|(${l})\\b` }, { begin: "\\b(0|[1-9](_?[0-9])*)n\\b" }, { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b" }, { begin: "\\b0[bB][0-1](_?[0-1])*n?\\b" }, { begin: "\\b0[oO][0-7](_?[0-7])*n?\\b" }, { begin: "\\b0[0-7]+n?\\b" }], relevance: 0 }, f = { className: "subst", begin: "\\$\\{", end: "\\}", keywords: c, contains: [] }, h = { begin: "html`", end: "", starts: { end: "`", returnEnd: !1, contains: [t.BACKSLASH_ESCAPE, f], subLanguage: "xml" } }, m = { begin: "css`", end: "", starts: { end: "`", returnEnd: !1, contains: [t.BACKSLASH_ESCAPE, f], subLanguage: "css" } }, x = { begin: "gql`", end: "", starts: { end: "`", returnEnd: !1, contains: [t.BACKSLASH_ESCAPE, f], subLanguage: "graphql" } }, C = { className: "string", begin: "`", end: "`", contains: [t.BACKSLASH_ESCAPE, f] }, b = { className: "comment", variants: [t.COMMENT(/\/\*\*(?!\/)/, "\\*/", { relevance: 0, contains: [{ begin: "(?=@[A-Za-z]+)", relevance: 0, contains: [{ className: "doctag", begin: "@[A-Za-z]+" }, { className: "type", begin: "\\{", end: "\\}", excludeEnd: !0, excludeBegin: !0, relevance: 0 }, { className: "variable", begin: r + "(?=\\s*(-)|$)", endsParent: !0, relevance: 0 }, { begin: /(?=[^\n])\s/, relevance: 0 }] }] }), t.C_BLOCK_COMMENT_MODE, t.C_LINE_COMMENT_MODE] }, E = [t.APOS_STRING_MODE, t.QUOTE_STRING_MODE, h, m, x, C, { match: /\$\d+/ }, d]; f.contains = E.concat({ begin: /\{/, end: /\}/, keywords: c, contains: ["self"].concat(E) }); const q = [].concat(b, f.contains), T = q.concat([{ begin: /\(/, end: /\)/, keywords: c, contains: ["self"].concat(q) }]), k = { className: "params", begin: /\(/, end: /\)/, excludeBegin: !0, excludeEnd: !0, keywords: c, contains: T }, B = { variants: [{ match: [/class/, /\s+/, r, /\s+/, /extends/, /\s+/, e.concat(r, "(", e.concat(/\./, r), ")*")], scope: { 1: "keyword", 3: "title.class", 5: "keyword", 7: "title.class.inherited" } }, { match: [/class/, /\s+/, r], scope: { 1: "keyword", 3: "title.class" } }] }, U = { relevance: 0, match: e.either(/\bJSON/, /\b[A-Z][a-z]+([A-Z][a-z]*|\d)*/, /\b[A-Z]{2,}([A-Z][a-z]+|\d)+([A-Z][a-z]*)*/, /\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\d)*([A-Z][a-z]*)*/), className: "title.class", keywords: { _: [...cn, ...an] } }, G = { label: "use_strict", className: "meta", relevance: 10, begin: /^\s*['"]use (strict|asm)['"]/ }, N = { variants: [{ match: [/function/, /\s+/, r, /(?=\s*\()/] }, { match: [/function/, /\s*(?=\()/] }], className: { 1: "keyword", 3: "title.function" }, label: "func.def", contains: [k], illegal: /%/ }, P = { relevance: 0, match: /\b[A-Z][A-Z_0-9]+\b/, className: "variable.constant" }; function ce(y) { return e.concat("(?!", y.join("|"), ")") } const re = { match: e.concat(/\b/, ce([...ln, "super", "import"]), r, e.lookahead(/\(/)), className: "title.function", relevance: 0 }, _ = { begin: e.concat(/\./, e.lookahead(e.concat(r, /(?![0-9A-Za-z$_(])/))), end: r, excludeBegin: !0, keywords: "prototype", className: "property", relevance: 0 }, O = { match: [/get|set/, /\s+/, r, /(?=\()/], className: { 1: "keyword", 3: "title.function" }, contains: [{ begin: /\(\)/ }, k] }, L = "(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|" + t.UNDERSCORE_IDENT_RE + ")\\s*=>", g = { match: [/const|var|let/, /\s+/, r, /\s*/, /=\s*/, /(async\s*)?/, e.lookahead(L)], keywords: "async", className: { 1: "keyword", 3: "title.function" }, contains: [k] }; return { name: "JavaScript", aliases: ["js", "jsx", "mjs", "cjs"], keywords: c, exports: { PARAMS_CONTAINS: T, CLASS_REFERENCE: U }, illegal: /#(?![$_A-z])/, contains: [t.SHEBANG({ label: "shebang", binary: "node", relevance: 5 }), G, t.APOS_STRING_MODE, t.QUOTE_STRING_MODE, h, m, x, C, b, { match: /\$\d+/ }, d, U, { className: "attr", begin: r + e.lookahead(":"), relevance: 0 }, g, { begin: "(" + t.RE_STARTERS_RE + "|\\b(case|return|throw)\\b)\\s*", keywords: "return throw case", relevance: 0, contains: [b, t.REGEXP_MODE, { className: "function", begin: L, returnBegin: !0, end: "\\s*=>", contains: [{ className: "params", variants: [{ begin: t.UNDERSCORE_IDENT_RE, relevance: 0 }, { className: null, begin: /\(\s*\)/, skip: !0 }, { begin: /\(/, end: /\)/, excludeBegin: !0, excludeEnd: !0, keywords: c, contains: T }] }] }, { begin: /,/, relevance: 0 }, { match: /\s+/, relevance: 0 }, { variants: [{ begin: o.begin, end: o.end }, { match: s }, { begin: i.begin, "on:begin": i.isTrulyOpeningTag, end: i.end }], subLanguage: "xml", contains: [{ begin: i.begin, end: i.end, skip: !0, contains: ["self"] }] }] }, N, { beginKeywords: "while if switch catch for" }, { begin: "\\b(?!function)" + t.UNDERSCORE_IDENT_RE + "\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{", returnBegin: !0, label: "func.def", contains: [k, t.inherit(t.TITLE_MODE, { begin: r, className: "title.function" })] }, { match: /\.\.\./, relevance: 0 }, _, { match: "\\$" + r, relevance: 0 }, { match: [/\bconstructor(?=\s*\()/], className: { 1: "title.function" }, contains: [k] }, re, P, B, O, { match: /\$[(.]/ }] } } const un = (t, e) => { const n = t.__vccOpts || t; for (const [r, o] of e) n[r] = o; return n }, So = {}, Do = { class: "chat-button" }; function To(t, e) { return p.openBlock(), p.createElementBlock("button", Do, [p.renderSlot(t.$slots, "default")]) } const Ro = un(So, [["render", To]]); function No() { const t = new Map; function e(o, s) { const i = t.get(o); i && i.splice(i.indexOf(s) >>> 0, 1) } function n(o, s) { let i = t.get(o); return i ? i.push(s) : i = [s], t.set(o, i), () => e(o, s) } function r(o, s) { const i = t.get(o); i && i.slice().forEach(async c => { await c(s) }) } return { on: n, off: e, emit: r } } function Lo(t) { if (!document.querySelector(t)) { const n = document.createElement("div"); t.startsWith("#") && (n.id = t.replace("#", "")), t.startsWith(".") && n.classList.add(t.replace(".", "")), document.body.appendChild(n) } } const he = No(), Bo = { class: "chat-layout" }, Mo = { key: 0, class: "chat-header" }, Io = { key: 2, class: "chat-footer" }, Oo = p.defineComponent({ __name: "Layout", setup(t) { const e = p.ref(null); function n() { const r = e.value; r && (r.scrollTop = r.scrollHeight) } return p.onMounted(() => { he.on("scrollToBottom", n), window.addEventListener("resize", n) }), p.onBeforeUnmount(() => { he.off("scrollToBottom", n), window.removeEventListener("resize", n) }), (r, o) => (p.openBlock(), p.createElementBlock("main", Bo, [r.$slots.header ? (p.openBlock(), p.createElementBlock("div", Mo, [p.renderSlot(r.$slots, "header")])) : p.createCommentVNode("", !0), r.$slots.default ? (p.openBlock(), p.createElementBlock("div", { key: 1, ref_key: "chatBodyRef", ref: e, class: "chat-body" }, [p.renderSlot(r.$slots, "default")], 512)) : p.createCommentVNode("", !0), r.$slots.footer ? (p.openBlock(), p.createElementBlock("div", Io, [p.renderSlot(r.$slots, "footer")])) : p.createCommentVNode("", !0)])) } }), qe = { webhookUrl: "http://localhost:5678", webhookConfig: { method: "POST", headers: {} }, target: "#n8n-chat", mode: "window", loadPreviousSession: !0, chatInputKey: "chatInput", chatSessionKey: "sessionId", defaultLanguage: "en", showWelcomeScreen: !1, initialMessages: ["Hi there! üëã", "My name is Nathan. How can I assist you today?"], i18n: { en: { title: "Hi there! üëã", subtitle: "Start a chat. We're here to help you 24/7.", footer: "", getStarted: "New Conversation", inputPlaceholder: "Type your question.." } }, theme: {} }, Fo = "#n8n-chat", pn = "n8n-chat/sessionId", fn = "Chat", hn = "ChatOptions"; function it() { return p.inject(fn) } function at() { return { options: p.inject(hn) } } function Oe() { const { options: t } = at(), e = (t == null ? void 0 : t.defaultLanguage) ?? "en"; function n(o) { var s, i; return ((i = (s = t == null ? void 0 : t.i18n) == null ? void 0 : s[e]) == null ? void 0 : i[o]) ?? o } function r(o) { var s, i; return !!((i = (s = t == null ? void 0 : t.i18n) == null ? void 0 : s[e]) != null && i[o]) } return { t: n, te: r } } const Po = { class: "chat-get-started" }, zo = p.defineComponent({ __name: "GetStarted", setup(t) { const { t: e } = Oe(); return (n, r) => (p.openBlock(), p.createElementBlock("div", Po, [p.createVNode(Ro, { onClick: r[0] || (r[0] = o => n.$emit("click:button")) }, { default: p.withCtx(() => [p.createTextVNode(p.toDisplayString(p.unref(e)("getStarted")), 1)]), _: 1 })])) } }), Uo = {}, Vo = { class: "chat-powered-by" }, $o = p.createElementVNode("a", { href: "https://n8n.io?utm_source=n8n-external&utm_medium=widget-powered-by" }, "n8n", -1); function Go(t, e) { return p.openBlock(), p.createElementBlock("div", Vo, [p.createTextVNode(" Powered by "), $o]) } const Ho = un(Uo, [["render", Go]]), jo = { class: "chat-get-started-footer" }, Zo = { key: 0 }, Wo = p.defineComponent({ __name: "GetStartedFooter", setup(t) { const { t: e, te: n } = Oe(); return (r, o) => (p.openBlock(), p.createElementBlock("div", jo, [p.unref(n)("footer") ? (p.openBlock(), p.createElementBlock("div", Zo, p.toDisplayString(p.unref(e)("footer")), 1)) : p.createCommentVNode("", !0), p.createVNode(Ho)])) } }); var I = {}, dn = {
		Aacute: "√Å", aacute: "√°", Abreve: "ƒÇ", abreve: "ƒÉ", ac: "‚àæ", acd: "‚àø", acE: "‚àæÃ≥", Acirc: "√Ç", acirc: "√¢", acute: "¬¥", Acy: "–ê", acy: "–∞", AElig: "√Ü", aelig: "√¶", af: "‚Å°", Afr: "ùîÑ", afr: "ùîû", Agrave: "√Ä", agrave: "√†", alefsym: "‚Ñµ", aleph: "‚Ñµ", Alpha: "Œë", alpha: "Œ±", Amacr: "ƒÄ", amacr: "ƒÅ", amalg: "‚®ø", amp: "&", AMP: "&", andand: "‚©ï", And: "‚©ì", and: "‚àß", andd: "‚©ú", andslope: "‚©ò", andv: "‚©ö", ang: "‚à†", ange: "‚¶§", angle: "‚à†", angmsdaa: "‚¶®", angmsdab: "‚¶©", angmsdac: "‚¶™", angmsdad: "‚¶´", angmsdae: "‚¶¨", angmsdaf: "‚¶≠", angmsdag: "‚¶Æ", angmsdah: "‚¶Ø", angmsd: "‚à°", angrt: "‚àü", angrtvb: "‚äæ", angrtvbd: "‚¶ù", angsph: "‚à¢", angst: "√Ö", angzarr: "‚çº", Aogon: "ƒÑ", aogon: "ƒÖ", Aopf: "ùî∏", aopf: "ùïí", apacir: "‚©Ø", ap: "‚âà", apE: "‚©∞", ape: "‚âä", apid: "‚âã", apos: "'", ApplyFunction: "‚Å°", approx: "‚âà", approxeq: "‚âä", Aring: "√Ö", aring: "√•", Ascr: "ùíú", ascr: "ùí∂", Assign: "‚âî", ast: "*", asymp: "‚âà", asympeq: "‚âç", Atilde: "√É", atilde: "√£", Auml: "√Ñ", auml: "√§", awconint: "‚à≥", awint: "‚®ë", backcong: "‚âå", backepsilon: "œ∂", backprime: "‚Äµ", backsim: "‚àΩ", backsimeq: "‚ãç", Backslash: "‚àñ", Barv: "‚´ß", barvee: "‚äΩ", barwed: "‚åÖ", Barwed: "‚åÜ", barwedge: "‚åÖ", bbrk: "‚éµ", bbrktbrk: "‚é∂", bcong: "‚âå", Bcy: "–ë", bcy: "–±", bdquo: "‚Äû", becaus: "‚àµ", because: "‚àµ", Because: "‚àµ", bemptyv: "‚¶∞", bepsi: "œ∂", bernou: "‚Ñ¨", Bernoullis: "‚Ñ¨", Beta: "Œí", beta: "Œ≤", beth: "‚Ñ∂", between: "‚â¨", Bfr: "ùîÖ", bfr: "ùîü", bigcap: "‚ãÇ", bigcirc: "‚óØ", bigcup: "‚ãÉ", bigodot: "‚®Ä", bigoplus: "‚®Å", bigotimes: "‚®Ç", bigsqcup: "‚®Ü", bigstar: "‚òÖ", bigtriangledown: "‚ñΩ", bigtriangleup: "‚ñ≥", biguplus: "‚®Ñ", bigvee: "‚ãÅ", bigwedge: "‚ãÄ", bkarow: "‚§ç", blacklozenge: "‚ß´", blacksquare: "‚ñ™", blacktriangle: "‚ñ¥", blacktriangledown: "‚ñæ", blacktriangleleft: "‚óÇ", blacktriangleright: "‚ñ∏", blank: "‚ê£", blk12: "‚ñí", blk14: "‚ñë", blk34: "‚ñì", block: "‚ñà", bne: "=‚É•", bnequiv: "‚â°‚É•", bNot: "‚´≠", bnot: "‚åê", Bopf: "ùîπ", bopf: "ùïì", bot: "‚ä•", bottom: "‚ä•", bowtie: "‚ãà", boxbox: "‚ßâ", boxdl: "‚îê", boxdL: "‚ïï", boxDl: "‚ïñ", boxDL: "‚ïó", boxdr: "‚îå", boxdR: "‚ïí", boxDr: "‚ïì", boxDR: "‚ïî", boxh: "‚îÄ", boxH: "‚ïê", boxhd: "‚î¨", boxHd: "‚ï§", boxhD: "‚ï•", boxHD: "‚ï¶", boxhu: "‚î¥", boxHu: "‚ïß", boxhU: "‚ï®", boxHU: "‚ï©", boxminus: "‚äü", boxplus: "‚äû", boxtimes: "‚ä†", boxul: "‚îò", boxuL: "‚ïõ", boxUl: "‚ïú", boxUL: "‚ïù", boxur: "‚îî", boxuR: "‚ïò", boxUr: "‚ïô", boxUR: "‚ïö", boxv: "‚îÇ", boxV: "‚ïë", boxvh: "‚îº", boxvH: "‚ï™", boxVh: "‚ï´", boxVH: "‚ï¨", boxvl: "‚î§", boxvL: "‚ï°", boxVl: "‚ï¢", boxVL: "‚ï£", boxvr: "‚îú", boxvR: "‚ïû", boxVr: "‚ïü", boxVR: "‚ï†", bprime: "‚Äµ", breve: "Àò", Breve: "Àò", brvbar: "¬¶", bscr: "ùí∑", Bscr: "‚Ñ¨", bsemi: "‚Åè", bsim: "‚àΩ", bsime: "‚ãç", bsolb: "‚ßÖ", bsol: "\\", bsolhsub: "‚üà", bull: "‚Ä¢", bullet: "‚Ä¢", bump: "‚âé", bumpE: "‚™Æ", bumpe: "‚âè", Bumpeq: "‚âé", bumpeq: "‚âè", Cacute: "ƒÜ", cacute: "ƒá", capand: "‚©Ñ", capbrcup: "‚©â", capcap: "‚©ã", cap: "‚à©", Cap: "‚ãí", capcup: "‚©á", capdot: "‚©Ä", CapitalDifferentialD: "‚ÖÖ", caps: "‚à©Ô∏Ä", caret: "‚ÅÅ", caron: "Àá", Cayleys: "‚Ñ≠", ccaps: "‚©ç", Ccaron: "ƒå", ccaron: "ƒç", Ccedil: "√á", ccedil: "√ß", Ccirc: "ƒà", ccirc: "ƒâ", Cconint: "‚à∞", ccups: "‚©å", ccupssm: "‚©ê", Cdot: "ƒä", cdot: "ƒã", cedil: "¬∏", Cedilla: "¬∏", cemptyv: "‚¶≤", cent: "¬¢", centerdot: "¬∑", CenterDot: "¬∑", cfr: "ùî†", Cfr: "‚Ñ≠", CHcy: "–ß", chcy: "—á", check: "‚úì", checkmark: "‚úì", Chi: "Œß", chi: "œá", circ: "ÀÜ", circeq: "‚âó", circlearrowleft: "‚Ü∫", circlearrowright: "‚Üª", circledast: "‚äõ", circledcirc: "‚äö", circleddash: "‚äù", CircleDot: "‚äô", circledR: "¬Æ", circledS: "‚ìà", CircleMinus: "‚äñ", CirclePlus: "‚äï", CircleTimes: "‚äó", cir: "‚óã", cirE: "‚ßÉ", cire: "‚âó", cirfnint: "‚®ê", cirmid: "‚´Ø", cirscir: "‚ßÇ", ClockwiseContourIntegral: "‚à≤", CloseCurlyDoubleQuote: "‚Äù", CloseCurlyQuote: "‚Äô", clubs: "‚ô£", clubsuit: "‚ô£", colon: ":", Colon: "‚à∑", Colone: "‚©¥", colone: "‚âî", coloneq: "‚âî", comma: ",", commat: "@", comp: "‚àÅ", compfn: "‚àò", complement: "‚àÅ", complexes: "‚ÑÇ", cong: "‚âÖ", congdot: "‚©≠", Congruent: "‚â°", conint: "‚àÆ", Conint: "‚àØ", ContourIntegral: "‚àÆ", copf: "ùïî", Copf: "‚ÑÇ", coprod: "‚àê", Coproduct: "‚àê", copy: "¬©", COPY: "¬©", copysr: "‚Ñó", CounterClockwiseContourIntegral: "‚à≥", crarr: "‚Üµ", cross: "‚úó", Cross: "‚®Ø", Cscr: "ùíû", cscr: "ùí∏", csub: "‚´è", csube: "‚´ë", csup: "‚´ê", csupe: "‚´í", ctdot: "‚ãØ", cudarrl: "‚§∏", cudarrr: "‚§µ", cuepr: "‚ãû", cuesc: "‚ãü", cularr: "‚Ü∂", cularrp: "‚§Ω", cupbrcap: "‚©à", cupcap: "‚©Ü", CupCap: "‚âç", cup: "‚à™", Cup: "‚ãì", cupcup: "‚©ä", cupdot: "‚äç", cupor: "‚©Ö", cups: "‚à™Ô∏Ä", curarr: "‚Ü∑", curarrm: "‚§º", curlyeqprec: "‚ãû", curlyeqsucc: "‚ãü", curlyvee: "‚ãé", curlywedge: "‚ãè", curren: "¬§", curvearrowleft: "‚Ü∂", curvearrowright: "‚Ü∑", cuvee: "‚ãé", cuwed: "‚ãè", cwconint: "‚à≤", cwint: "‚à±", cylcty: "‚å≠", dagger: "‚Ä†", Dagger: "‚Ä°", daleth: "‚Ñ∏", darr: "‚Üì", Darr: "‚Ü°", dArr: "‚áì", dash: "‚Äê", Dashv: "‚´§", dashv: "‚ä£", dbkarow: "‚§è", dblac: "Àù", Dcaron: "ƒé", dcaron: "ƒè", Dcy: "–î", dcy: "–¥", ddagger: "‚Ä°", ddarr: "‚áä", DD: "‚ÖÖ", dd: "‚ÖÜ", DDotrahd: "‚§ë", ddotseq: "‚©∑", deg: "¬∞", Del: "‚àá", Delta: "Œî", delta: "Œ¥", demptyv: "‚¶±", dfisht: "‚•ø", Dfr: "ùîá", dfr: "ùî°", dHar: "‚••", dharl: "‚áÉ", dharr: "‚áÇ", DiacriticalAcute: "¬¥", DiacriticalDot: "Àô", DiacriticalDoubleAcute: "Àù", DiacriticalGrave: "`", DiacriticalTilde: "Àú", diam: "‚ãÑ", diamond: "‚ãÑ", Diamond: "‚ãÑ", diamondsuit: "‚ô¶", diams: "‚ô¶", die: "¬®", DifferentialD: "‚ÖÜ", digamma: "œù", disin: "‚ã≤", div: "√∑", divide: "√∑", divideontimes: "‚ãá", divonx: "‚ãá", DJcy: "–Ç", djcy: "—í", dlcorn: "‚åû", dlcrop: "‚åç", dollar: "$", Dopf: "ùîª", dopf: "ùïï", Dot: "¬®", dot: "Àô", DotDot: "‚Éú", doteq: "‚âê", doteqdot: "‚âë", DotEqual: "‚âê", dotminus: "‚à∏", dotplus: "‚àî", dotsquare: "‚ä°", doublebarwedge: "‚åÜ", DoubleContourIntegral: "‚àØ", DoubleDot: "¬®", DoubleDownArrow: "‚áì", DoubleLeftArrow: "‚áê", DoubleLeftRightArrow: "‚áî", DoubleLeftTee: "‚´§", DoubleLongLeftArrow: "‚ü∏", DoubleLongLeftRightArrow: "‚ü∫", DoubleLongRightArrow: "‚üπ", DoubleRightArrow: "‚áí", DoubleRightTee: "‚ä®", DoubleUpArrow: "‚áë", DoubleUpDownArrow: "‚áï", DoubleVerticalBar: "‚à•", DownArrowBar: "‚§ì", downarrow: "‚Üì", DownArrow: "‚Üì", Downarrow: "‚áì", DownArrowUpArrow: "‚áµ", DownBreve: "Ãë", downdownarrows: "‚áä", downharpoonleft: "‚áÉ", downharpoonright: "‚áÇ", DownLeftRightVector: "‚•ê", DownLeftTeeVector: "‚•û", DownLeftVectorBar: "‚•ñ", DownLeftVector: "‚ÜΩ", DownRightTeeVector: "‚•ü", DownRightVectorBar: "‚•ó", DownRightVector: "‚áÅ", DownTeeArrow: "‚Üß", DownTee: "‚ä§", drbkarow: "‚§ê", drcorn: "‚åü", drcrop: "‚åå", Dscr: "ùíü", dscr: "ùíπ", DScy: "–Ö", dscy: "—ï", dsol: "‚ß∂", Dstrok: "ƒê", dstrok: "ƒë", dtdot: "‚ã±", dtri: "‚ñø", dtrif: "‚ñæ", duarr: "‚áµ", duhar: "‚•Ø", dwangle: "‚¶¶", DZcy: "–è", dzcy: "—ü", dzigrarr: "‚üø", Eacute: "√â", eacute: "√©", easter: "‚©Æ", Ecaron: "ƒö", ecaron: "ƒõ", Ecirc: "√ä", ecirc: "√™", ecir: "‚âñ", ecolon: "‚âï", Ecy: "–≠", ecy: "—ç", eDDot: "‚©∑", Edot: "ƒñ", edot: "ƒó", eDot: "‚âë", ee: "‚Öá", efDot: "‚âí", Efr: "ùîà", efr: "ùî¢", eg: "‚™ö", Egrave: "√à", egrave: "√®", egs: "‚™ñ", egsdot: "‚™ò", el: "‚™ô", Element: "‚àà", elinters: "‚èß", ell: "‚Ñì", els: "‚™ï", elsdot: "‚™ó", Emacr: "ƒí", emacr: "ƒì", empty: "‚àÖ", emptyset: "‚àÖ", EmptySmallSquare: "‚óª", emptyv: "‚àÖ", EmptyVerySmallSquare: "‚ñ´", emsp13: "‚ÄÑ", emsp14: "‚ÄÖ", emsp: "‚ÄÉ", ENG: "≈ä", eng: "≈ã", ensp: "‚ÄÇ", Eogon: "ƒò", eogon: "ƒô", Eopf: "ùîº", eopf: "ùïñ", epar: "‚ãï", eparsl: "‚ß£", eplus: "‚©±", epsi: "Œµ", Epsilon: "Œï", epsilon: "Œµ", epsiv: "œµ", eqcirc: "‚âñ", eqcolon: "‚âï", eqsim: "‚âÇ", eqslantgtr: "‚™ñ", eqslantless: "‚™ï", Equal: "‚©µ", equals: "=", EqualTilde: "‚âÇ", equest: "‚âü", Equilibrium: "‚áå", equiv: "‚â°", equivDD: "‚©∏", eqvparsl: "‚ß•", erarr: "‚•±", erDot: "‚âì", escr: "‚ÑØ", Escr: "‚Ñ∞", esdot: "‚âê", Esim: "‚©≥", esim: "‚âÇ", Eta: "Œó", eta: "Œ∑", ETH: "√ê", eth: "√∞", Euml: "√ã", euml: "√´", euro: "‚Ç¨", excl: "!", exist: "‚àÉ", Exists: "‚àÉ", expectation: "‚Ñ∞", exponentiale: "‚Öá", ExponentialE: "‚Öá", fallingdotseq: "‚âí", Fcy: "–§", fcy: "—Ñ", female: "‚ôÄ", ffilig: "Ô¨É", fflig: "Ô¨Ä", ffllig: "Ô¨Ñ", Ffr: "ùîâ", ffr: "ùî£", filig: "Ô¨Å", FilledSmallSquare: "‚óº", FilledVerySmallSquare: "‚ñ™", fjlig: "fj", flat: "‚ô≠", fllig: "Ô¨Ç", fltns: "‚ñ±", fnof: "∆í", Fopf: "ùîΩ", fopf: "ùïó", forall: "‚àÄ", ForAll: "‚àÄ", fork: "‚ãî", forkv: "‚´ô", Fouriertrf: "‚Ñ±", fpartint: "‚®ç", frac12: "¬Ω", frac13: "‚Öì", frac14: "¬º", frac15: "‚Öï", frac16: "‚Öô", frac18: "‚Öõ", frac23: "‚Öî", frac25: "‚Öñ", frac34: "¬æ", frac35: "‚Öó", frac38: "‚Öú", frac45: "‚Öò", frac56: "‚Öö", frac58: "‚Öù", frac78: "‚Öû", frasl: "‚ÅÑ", frown: "‚å¢", fscr: "ùíª", Fscr: "‚Ñ±", gacute: "«µ", Gamma: "Œì", gamma: "Œ≥", Gammad: "œú", gammad: "œù", gap: "‚™Ü", Gbreve: "ƒû", gbreve: "ƒü", Gcedil: "ƒ¢", Gcirc: "ƒú", gcirc: "ƒù", Gcy: "–ì", gcy: "–≥", Gdot: "ƒ†", gdot: "ƒ°", ge: "‚â•", gE: "‚âß", gEl: "‚™å", gel: "‚ãõ", geq: "‚â•", geqq: "‚âß", geqslant: "‚©æ", gescc: "‚™©", ges: "‚©æ", gesdot: "‚™Ä", gesdoto: "‚™Ç", gesdotol: "‚™Ñ", gesl: "‚ãõÔ∏Ä", gesles: "‚™î", Gfr: "ùîä", gfr: "ùî§", gg: "‚â´", Gg: "‚ãô", ggg: "‚ãô", gimel: "‚Ñ∑", GJcy: "–É", gjcy: "—ì", gla: "‚™•", gl: "‚â∑", glE: "‚™í", glj: "‚™§", gnap: "‚™ä", gnapprox: "‚™ä", gne: "‚™à", gnE: "‚â©", gneq: "‚™à", gneqq: "‚â©", gnsim: "‚ãß", Gopf: "ùîæ", gopf: "ùïò", grave: "`", GreaterEqual: "‚â•", GreaterEqualLess: "‚ãõ", GreaterFullEqual: "‚âß", GreaterGreater: "‚™¢", GreaterLess: "‚â∑", GreaterSlantEqual: "‚©æ", GreaterTilde: "‚â≥", Gscr: "ùí¢", gscr: "‚Ñä", gsim: "‚â≥", gsime: "‚™é", gsiml: "‚™ê", gtcc: "‚™ß", gtcir: "‚©∫", gt: ">", GT: ">", Gt: "‚â´", gtdot: "‚ãó", gtlPar: "‚¶ï", gtquest: "‚©º", gtrapprox: "‚™Ü", gtrarr: "‚•∏", gtrdot: "‚ãó", gtreqless: "‚ãõ", gtreqqless: "‚™å", gtrless: "‚â∑", gtrsim: "‚â≥", gvertneqq: "‚â©Ô∏Ä", gvnE: "‚â©Ô∏Ä", Hacek: "Àá", hairsp: "‚Ää", half: "¬Ω", hamilt: "‚Ñã", HARDcy: "–™", hardcy: "—ä", harrcir: "‚•à", harr: "‚Üî", hArr: "‚áî", harrw: "‚Ü≠", Hat: "^", hbar: "‚Ñè", Hcirc: "ƒ§", hcirc: "ƒ•", hearts: "‚ô•", heartsuit: "‚ô•", hellip: "‚Ä¶", hercon: "‚äπ", hfr: "ùî•", Hfr: "‚Ñå", HilbertSpace: "‚Ñã", hksearow: "‚§•", hkswarow: "‚§¶", hoarr: "‚áø", homtht: "‚àª", hookleftarrow: "‚Ü©", hookrightarrow: "‚Ü™", hopf: "ùïô", Hopf: "‚Ñç", horbar: "‚Äï", HorizontalLine: "‚îÄ", hscr: "ùíΩ", Hscr: "‚Ñã", hslash: "‚Ñè", Hstrok: "ƒ¶", hstrok: "ƒß", HumpDownHump: "‚âé", HumpEqual: "‚âè", hybull: "‚ÅÉ", hyphen: "‚Äê", Iacute: "√ç", iacute: "√≠", ic: "‚Å£", Icirc: "√é", icirc: "√Æ", Icy: "–ò", icy: "–∏", Idot: "ƒ∞", IEcy: "–ï", iecy: "–µ", iexcl: "¬°", iff: "‚áî", ifr: "ùî¶", Ifr: "‚Ñë", Igrave: "√å", igrave: "√¨", ii: "‚Öà", iiiint: "‚®å", iiint: "‚à≠", iinfin: "‚ßú", iiota: "‚Ñ©", IJlig: "ƒ≤", ijlig: "ƒ≥", Imacr: "ƒ™", imacr: "ƒ´", image: "‚Ñë", ImaginaryI: "‚Öà", imagline: "‚Ñê", imagpart: "‚Ñë", imath: "ƒ±", Im: "‚Ñë", imof: "‚ä∑", imped: "∆µ", Implies: "‚áí", incare: "‚ÑÖ", in: "‚àà", infin: "‚àû", infintie: "‚ßù", inodot: "ƒ±", intcal: "‚ä∫", int: "‚à´", Int: "‚à¨", integers: "‚Ñ§", Integral: "‚à´", intercal: "‚ä∫", Intersection: "‚ãÇ", intlarhk: "‚®ó", intprod: "‚®º", InvisibleComma: "‚Å£", InvisibleTimes: "‚Å¢", IOcy: "–Å", iocy: "—ë", Iogon: "ƒÆ", iogon: "ƒØ", Iopf: "ùïÄ", iopf: "ùïö", Iota: "Œô", iota: "Œπ", iprod: "‚®º", iquest: "¬ø", iscr: "ùíæ", Iscr: "‚Ñê", isin: "‚àà", isindot: "‚ãµ", isinE: "‚ãπ", isins: "‚ã¥", isinsv: "‚ã≥", isinv: "‚àà", it: "‚Å¢", Itilde: "ƒ®", itilde: "ƒ©", Iukcy: "–Ü", iukcy: "—ñ", Iuml: "√è", iuml: "√Ø", Jcirc: "ƒ¥", jcirc: "ƒµ", Jcy: "–ô", jcy: "–π", Jfr: "ùîç", jfr: "ùîß", jmath: "»∑", Jopf: "ùïÅ", jopf: "ùïõ", Jscr: "ùí•", jscr: "ùíø", Jsercy: "–à", jsercy: "—ò", Jukcy: "–Ñ", jukcy: "—î", Kappa: "Œö", kappa: "Œ∫", kappav: "œ∞", Kcedil: "ƒ∂", kcedil: "ƒ∑", Kcy: "–ö", kcy: "–∫", Kfr: "ùîé", kfr: "ùî®", kgreen: "ƒ∏", KHcy: "–•", khcy: "—Ö", KJcy: "–å", kjcy: "—ú", Kopf: "ùïÇ", kopf: "ùïú", Kscr: "ùí¶", kscr: "ùìÄ", lAarr: "‚áö", Lacute: "ƒπ", lacute: "ƒ∫", laemptyv: "‚¶¥", lagran: "‚Ñí", Lambda: "Œõ", lambda: "Œª", lang: "‚ü®", Lang: "‚ü™", langd: "‚¶ë", langle: "‚ü®", lap: "‚™Ö", Laplacetrf: "‚Ñí", laquo: "¬´", larrb: "‚á§", larrbfs: "‚§ü", larr: "‚Üê", Larr: "‚Üû", lArr: "‚áê", larrfs: "‚§ù", larrhk: "‚Ü©", larrlp: "‚Ü´", larrpl: "‚§π", larrsim: "‚•≥", larrtl: "‚Ü¢", latail: "‚§ô", lAtail: "‚§õ", lat: "‚™´", late: "‚™≠", lates: "‚™≠Ô∏Ä", lbarr: "‚§å", lBarr: "‚§é", lbbrk: "‚ù≤", lbrace: "{", lbrack: "[", lbrke: "‚¶ã", lbrksld: "‚¶è", lbrkslu: "‚¶ç", Lcaron: "ƒΩ", lcaron: "ƒæ", Lcedil: "ƒª", lcedil: "ƒº", lceil: "‚åà", lcub: "{", Lcy: "–õ", lcy: "–ª", ldca: "‚§∂", ldquo: "‚Äú", ldquor: "‚Äû", ldrdhar: "‚•ß", ldrushar: "‚•ã", ldsh: "‚Ü≤", le: "‚â§", lE: "‚â¶", LeftAngleBracket: "‚ü®", LeftArrowBar: "‚á§", leftarrow: "‚Üê", LeftArrow: "‚Üê", Leftarrow: "‚áê", LeftArrowRightArrow: "‚áÜ", leftarrowtail: "‚Ü¢", LeftCeiling: "‚åà", LeftDoubleBracket: "‚ü¶", LeftDownTeeVector: "‚•°", LeftDownVectorBar: "‚•ô", LeftDownVector: "‚áÉ", LeftFloor: "‚åä", leftharpoondown: "‚ÜΩ", leftharpoonup: "‚Üº", leftleftarrows: "‚áá", leftrightarrow: "‚Üî", LeftRightArrow: "‚Üî", Leftrightarrow: "‚áî", leftrightarrows: "‚áÜ", leftrightharpoons: "‚áã", leftrightsquigarrow: "‚Ü≠", LeftRightVector: "‚•é", LeftTeeArrow: "‚Ü§", LeftTee: "‚ä£", LeftTeeVector: "‚•ö", leftthreetimes: "‚ãã", LeftTriangleBar: "‚ßè", LeftTriangle: "‚ä≤", LeftTriangleEqual: "‚ä¥", LeftUpDownVector: "‚•ë", LeftUpTeeVector: "‚•†", LeftUpVectorBar: "‚•ò", LeftUpVector: "‚Üø", LeftVectorBar: "‚•í", LeftVector: "‚Üº", lEg: "‚™ã", leg: "‚ãö", leq: "‚â§", leqq: "‚â¶", leqslant: "‚©Ω", lescc: "‚™®", les: "‚©Ω", lesdot: "‚©ø", lesdoto: "‚™Å", lesdotor: "‚™É", lesg: "‚ãöÔ∏Ä", lesges: "‚™ì", lessapprox: "‚™Ö", lessdot: "‚ãñ", lesseqgtr: "‚ãö", lesseqqgtr: "‚™ã", LessEqualGreater: "‚ãö", LessFullEqual: "‚â¶", LessGreater: "‚â∂", lessgtr: "‚â∂", LessLess: "‚™°", lesssim: "‚â≤", LessSlantEqual: "‚©Ω", LessTilde: "‚â≤", lfisht: "‚•º", lfloor: "‚åä", Lfr: "ùîè", lfr: "ùî©", lg: "‚â∂", lgE: "‚™ë", lHar: "‚•¢", lhard: "‚ÜΩ", lharu: "‚Üº", lharul: "‚•™", lhblk: "‚ñÑ", LJcy: "–â", ljcy: "—ô", llarr: "‚áá", ll: "‚â™", Ll: "‚ãò", llcorner: "‚åû", Lleftarrow: "‚áö", llhard: "‚•´", lltri: "‚ó∫", Lmidot: "ƒø", lmidot: "≈Ä", lmoustache: "‚é∞", lmoust: "‚é∞", lnap: "‚™â", lnapprox: "‚™â", lne: "‚™á", lnE: "‚â®", lneq: "‚™á", lneqq: "‚â®", lnsim: "‚ã¶", loang: "‚ü¨", loarr: "‚áΩ", lobrk: "‚ü¶", longleftarrow: "‚üµ", LongLeftArrow: "‚üµ", Longleftarrow: "‚ü∏", longleftrightarrow: "‚ü∑", LongLeftRightArrow: "‚ü∑", Longleftrightarrow: "‚ü∫", longmapsto: "‚üº", longrightarrow: "‚ü∂", LongRightArrow: "‚ü∂", Longrightarrow: "‚üπ", looparrowleft: "‚Ü´", looparrowright: "‚Ü¨", lopar: "‚¶Ö", Lopf: "ùïÉ", lopf: "ùïù", loplus: "‚®≠", lotimes: "‚®¥", lowast: "‚àó", lowbar: "_", LowerLeftArrow: "‚Üô", LowerRightArrow: "‚Üò", loz: "‚óä", lozenge: "‚óä", lozf: "‚ß´", lpar: "(", lparlt: "‚¶ì", lrarr: "‚áÜ", lrcorner: "‚åü", lrhar: "‚áã", lrhard: "‚•≠", lrm: "‚Äé", lrtri: "‚äø", lsaquo: "‚Äπ", lscr: "ùìÅ", Lscr: "‚Ñí", lsh: "‚Ü∞", Lsh: "‚Ü∞", lsim: "‚â≤", lsime: "‚™ç", lsimg: "‚™è", lsqb: "[", lsquo: "‚Äò", lsquor: "‚Äö", Lstrok: "≈Å", lstrok: "≈Ç", ltcc: "‚™¶", ltcir: "‚©π", lt: "<", LT: "<", Lt: "‚â™", ltdot: "‚ãñ", lthree: "‚ãã", ltimes: "‚ãâ", ltlarr: "‚•∂", ltquest: "‚©ª", ltri: "‚óÉ", ltrie: "‚ä¥", ltrif: "‚óÇ", ltrPar: "‚¶ñ", lurdshar: "‚•ä", luruhar: "‚•¶", lvertneqq: "‚â®Ô∏Ä", lvnE: "‚â®Ô∏Ä", macr: "¬Ø", male: "‚ôÇ", malt: "‚ú†", maltese: "‚ú†", Map: "‚§Ö", map: "‚Ü¶", mapsto: "‚Ü¶", mapstodown: "‚Üß", mapstoleft: "‚Ü§", mapstoup: "‚Ü•", marker: "‚ñÆ", mcomma: "‚®©", Mcy: "–ú", mcy: "–º", mdash: "‚Äî", mDDot: "‚à∫", measuredangle: "‚à°", MediumSpace: "‚Åü", Mellintrf: "‚Ñ≥", Mfr: "ùîê", mfr: "ùî™", mho: "‚Ñß", micro: "¬µ", midast: "*", midcir: "‚´∞", mid: "‚à£", middot: "¬∑", minusb: "‚äü", minus: "‚àí", minusd: "‚à∏", minusdu: "‚®™", MinusPlus: "‚àì", mlcp: "‚´õ", mldr: "‚Ä¶", mnplus: "‚àì", models: "‚äß", Mopf: "ùïÑ", mopf: "ùïû", mp: "‚àì", mscr: "ùìÇ", Mscr: "‚Ñ≥", mstpos: "‚àæ", Mu: "Œú", mu: "Œº", multimap: "‚ä∏", mumap: "‚ä∏", nabla: "‚àá", Nacute: "≈É", nacute: "≈Ñ", nang: "‚à†‚Éí", nap: "‚ââ", napE: "‚©∞Ã∏", napid: "‚âãÃ∏", napos: "≈â", napprox: "‚ââ", natural: "‚ôÆ", naturals: "‚Ñï", natur: "‚ôÆ", nbsp: "¬†", nbump: "‚âéÃ∏", nbumpe: "‚âèÃ∏", ncap: "‚©É", Ncaron: "≈á", ncaron: "≈à", Ncedil: "≈Ö", ncedil: "≈Ü", ncong: "‚âá", ncongdot: "‚©≠Ã∏", ncup: "‚©Ç", Ncy: "–ù", ncy: "–Ω", ndash: "‚Äì", nearhk: "‚§§", nearr: "‚Üó", neArr: "‚áó", nearrow: "‚Üó", ne: "‚â†", nedot: "‚âêÃ∏", NegativeMediumSpace: "‚Äã", NegativeThickSpace: "‚Äã", NegativeThinSpace: "‚Äã", NegativeVeryThinSpace: "‚Äã", nequiv: "‚â¢", nesear: "‚§®", nesim: "‚âÇÃ∏", NestedGreaterGreater: "‚â´", NestedLessLess: "‚â™", NewLine: `
`, nexist: "‚àÑ", nexists: "‚àÑ", Nfr: "ùîë", nfr: "ùî´", ngE: "‚âßÃ∏", nge: "‚â±", ngeq: "‚â±", ngeqq: "‚âßÃ∏", ngeqslant: "‚©æÃ∏", nges: "‚©æÃ∏", nGg: "‚ãôÃ∏", ngsim: "‚âµ", nGt: "‚â´‚Éí", ngt: "‚âØ", ngtr: "‚âØ", nGtv: "‚â´Ã∏", nharr: "‚ÜÆ", nhArr: "‚áé", nhpar: "‚´≤", ni: "‚àã", nis: "‚ãº", nisd: "‚ã∫", niv: "‚àã", NJcy: "–ä", njcy: "—ö", nlarr: "‚Üö", nlArr: "‚áç", nldr: "‚Ä•", nlE: "‚â¶Ã∏", nle: "‚â∞", nleftarrow: "‚Üö", nLeftarrow: "‚áç", nleftrightarrow: "‚ÜÆ", nLeftrightarrow: "‚áé", nleq: "‚â∞", nleqq: "‚â¶Ã∏", nleqslant: "‚©ΩÃ∏", nles: "‚©ΩÃ∏", nless: "‚âÆ", nLl: "‚ãòÃ∏", nlsim: "‚â¥", nLt: "‚â™‚Éí", nlt: "‚âÆ", nltri: "‚ã™", nltrie: "‚ã¨", nLtv: "‚â™Ã∏", nmid: "‚à§", NoBreak: "‚Å†", NonBreakingSpace: "¬†", nopf: "ùïü", Nopf: "‚Ñï", Not: "‚´¨", not: "¬¨", NotCongruent: "‚â¢", NotCupCap: "‚â≠", NotDoubleVerticalBar: "‚à¶", NotElement: "‚àâ", NotEqual: "‚â†", NotEqualTilde: "‚âÇÃ∏", NotExists: "‚àÑ", NotGreater: "‚âØ", NotGreaterEqual: "‚â±", NotGreaterFullEqual: "‚âßÃ∏", NotGreaterGreater: "‚â´Ã∏", NotGreaterLess: "‚âπ", NotGreaterSlantEqual: "‚©æÃ∏", NotGreaterTilde: "‚âµ", NotHumpDownHump: "‚âéÃ∏", NotHumpEqual: "‚âèÃ∏", notin: "‚àâ", notindot: "‚ãµÃ∏", notinE: "‚ãπÃ∏", notinva: "‚àâ", notinvb: "‚ã∑", notinvc: "‚ã∂", NotLeftTriangleBar: "‚ßèÃ∏", NotLeftTriangle: "‚ã™", NotLeftTriangleEqual: "‚ã¨", NotLess: "‚âÆ", NotLessEqual: "‚â∞", NotLessGreater: "‚â∏", NotLessLess: "‚â™Ã∏", NotLessSlantEqual: "‚©ΩÃ∏", NotLessTilde: "‚â¥", NotNestedGreaterGreater: "‚™¢Ã∏", NotNestedLessLess: "‚™°Ã∏", notni: "‚àå", notniva: "‚àå", notnivb: "‚ãæ", notnivc: "‚ãΩ", NotPrecedes: "‚äÄ", NotPrecedesEqual: "‚™ØÃ∏", NotPrecedesSlantEqual: "‚ã†", NotReverseElement: "‚àå", NotRightTriangleBar: "‚ßêÃ∏", NotRightTriangle: "‚ã´", NotRightTriangleEqual: "‚ã≠", NotSquareSubset: "‚äèÃ∏", NotSquareSubsetEqual: "‚ã¢", NotSquareSuperset: "‚äêÃ∏", NotSquareSupersetEqual: "‚ã£", NotSubset: "‚äÇ‚Éí", NotSubsetEqual: "‚äà", NotSucceeds: "‚äÅ", NotSucceedsEqual: "‚™∞Ã∏", NotSucceedsSlantEqual: "‚ã°", NotSucceedsTilde: "‚âøÃ∏", NotSuperset: "‚äÉ‚Éí", NotSupersetEqual: "‚äâ", NotTilde: "‚âÅ", NotTildeEqual: "‚âÑ", NotTildeFullEqual: "‚âá", NotTildeTilde: "‚ââ", NotVerticalBar: "‚à§", nparallel: "‚à¶", npar: "‚à¶", nparsl: "‚´Ω‚É•", npart: "‚àÇÃ∏", npolint: "‚®î", npr: "‚äÄ", nprcue: "‚ã†", nprec: "‚äÄ", npreceq: "‚™ØÃ∏", npre: "‚™ØÃ∏", nrarrc: "‚§≥Ã∏", nrarr: "‚Üõ", nrArr: "‚áè", nrarrw: "‚ÜùÃ∏", nrightarrow: "‚Üõ", nRightarrow: "‚áè", nrtri: "‚ã´", nrtrie: "‚ã≠", nsc: "‚äÅ", nsccue: "‚ã°", nsce: "‚™∞Ã∏", Nscr: "ùí©", nscr: "ùìÉ", nshortmid: "‚à§", nshortparallel: "‚à¶", nsim: "‚âÅ", nsime: "‚âÑ", nsimeq: "‚âÑ", nsmid: "‚à§", nspar: "‚à¶", nsqsube: "‚ã¢", nsqsupe: "‚ã£", nsub: "‚äÑ", nsubE: "‚´ÖÃ∏", nsube: "‚äà", nsubset: "‚äÇ‚Éí", nsubseteq: "‚äà", nsubseteqq: "‚´ÖÃ∏", nsucc: "‚äÅ", nsucceq: "‚™∞Ã∏", nsup: "‚äÖ", nsupE: "‚´ÜÃ∏", nsupe: "‚äâ", nsupset: "‚äÉ‚Éí", nsupseteq: "‚äâ", nsupseteqq: "‚´ÜÃ∏", ntgl: "‚âπ", Ntilde: "√ë", ntilde: "√±", ntlg: "‚â∏", ntriangleleft: "‚ã™", ntrianglelefteq: "‚ã¨", ntriangleright: "‚ã´", ntrianglerighteq: "‚ã≠", Nu: "Œù", nu: "ŒΩ", num: "#", numero: "‚Ññ", numsp: "‚Äá", nvap: "‚âç‚Éí", nvdash: "‚ä¨", nvDash: "‚ä≠", nVdash: "‚äÆ", nVDash: "‚äØ", nvge: "‚â•‚Éí", nvgt: ">‚Éí", nvHarr: "‚§Ñ", nvinfin: "‚ßû", nvlArr: "‚§Ç", nvle: "‚â§‚Éí", nvlt: "<‚Éí", nvltrie: "‚ä¥‚Éí", nvrArr: "‚§É", nvrtrie: "‚äµ‚Éí", nvsim: "‚àº‚Éí", nwarhk: "‚§£", nwarr: "‚Üñ", nwArr: "‚áñ", nwarrow: "‚Üñ", nwnear: "‚§ß", Oacute: "√ì", oacute: "√≥", oast: "‚äõ", Ocirc: "√î", ocirc: "√¥", ocir: "‚äö", Ocy: "–û", ocy: "–æ", odash: "‚äù", Odblac: "≈ê", odblac: "≈ë", odiv: "‚®∏", odot: "‚äô", odsold: "‚¶º", OElig: "≈í", oelig: "≈ì", ofcir: "‚¶ø", Ofr: "ùîí", ofr: "ùî¨", ogon: "Àõ", Ograve: "√í", ograve: "√≤", ogt: "‚ßÅ", ohbar: "‚¶µ", ohm: "Œ©", oint: "‚àÆ", olarr: "‚Ü∫", olcir: "‚¶æ", olcross: "‚¶ª", oline: "‚Äæ", olt: "‚ßÄ", Omacr: "≈å", omacr: "≈ç", Omega: "Œ©", omega: "œâ", Omicron: "Œü", omicron: "Œø", omid: "‚¶∂", ominus: "‚äñ", Oopf: "ùïÜ", oopf: "ùï†", opar: "‚¶∑", OpenCurlyDoubleQuote: "‚Äú", OpenCurlyQuote: "‚Äò", operp: "‚¶π", oplus: "‚äï", orarr: "‚Üª", Or: "‚©î", or: "‚à®", ord: "‚©ù", order: "‚Ñ¥", orderof: "‚Ñ¥", ordf: "¬™", ordm: "¬∫", origof: "‚ä∂", oror: "‚©ñ", orslope: "‚©ó", orv: "‚©õ", oS: "‚ìà", Oscr: "ùí™", oscr: "‚Ñ¥", Oslash: "√ò", oslash: "√∏", osol: "‚äò", Otilde: "√ï", otilde: "√µ", otimesas: "‚®∂", Otimes: "‚®∑", otimes: "‚äó", Ouml: "√ñ", ouml: "√∂", ovbar: "‚åΩ", OverBar: "‚Äæ", OverBrace: "‚èû", OverBracket: "‚é¥", OverParenthesis: "‚èú", para: "¬∂", parallel: "‚à•", par: "‚à•", parsim: "‚´≥", parsl: "‚´Ω", part: "‚àÇ", PartialD: "‚àÇ", Pcy: "–ü", pcy: "–ø", percnt: "%", period: ".", permil: "‚Ä∞", perp: "‚ä•", pertenk: "‚Ä±", Pfr: "ùîì", pfr: "ùî≠", Phi: "Œ¶", phi: "œÜ", phiv: "œï", phmmat: "‚Ñ≥", phone: "‚òé", Pi: "Œ†", pi: "œÄ", pitchfork: "‚ãî", piv: "œñ", planck: "‚Ñè", planckh: "‚Ñé", plankv: "‚Ñè", plusacir: "‚®£", plusb: "‚äû", pluscir: "‚®¢", plus: "+", plusdo: "‚àî", plusdu: "‚®•", pluse: "‚©≤", PlusMinus: "¬±", plusmn: "¬±", plussim: "‚®¶", plustwo: "‚®ß", pm: "¬±", Poincareplane: "‚Ñå", pointint: "‚®ï", popf: "ùï°", Popf: "‚Ñô", pound: "¬£", prap: "‚™∑", Pr: "‚™ª", pr: "‚â∫", prcue: "‚âº", precapprox: "‚™∑", prec: "‚â∫", preccurlyeq: "‚âº", Precedes: "‚â∫", PrecedesEqual: "‚™Ø", PrecedesSlantEqual: "‚âº", PrecedesTilde: "‚âæ", preceq: "‚™Ø", precnapprox: "‚™π", precneqq: "‚™µ", precnsim: "‚ã®", pre: "‚™Ø", prE: "‚™≥", precsim: "‚âæ", prime: "‚Ä≤", Prime: "‚Ä≥", primes: "‚Ñô", prnap: "‚™π", prnE: "‚™µ", prnsim: "‚ã®", prod: "‚àè", Product: "‚àè", profalar: "‚åÆ", profline: "‚åí", profsurf: "‚åì", prop: "‚àù", Proportional: "‚àù", Proportion: "‚à∑", propto: "‚àù", prsim: "‚âæ", prurel: "‚ä∞", Pscr: "ùí´", pscr: "ùìÖ", Psi: "Œ®", psi: "œà", puncsp: "‚Äà", Qfr: "ùîî", qfr: "ùîÆ", qint: "‚®å", qopf: "ùï¢", Qopf: "‚Ñö", qprime: "‚Åó", Qscr: "ùí¨", qscr: "ùìÜ", quaternions: "‚Ñç", quatint: "‚®ñ", quest: "?", questeq: "‚âü", quot: '"', QUOT: '"', rAarr: "‚áõ", race: "‚àΩÃ±", Racute: "≈î", racute: "≈ï", radic: "‚àö", raemptyv: "‚¶≥", rang: "‚ü©", Rang: "‚ü´", rangd: "‚¶í", range: "‚¶•", rangle: "‚ü©", raquo: "¬ª", rarrap: "‚•µ", rarrb: "‚á•", rarrbfs: "‚§†", rarrc: "‚§≥", rarr: "‚Üí", Rarr: "‚Ü†", rArr: "‚áí", rarrfs: "‚§û", rarrhk: "‚Ü™", rarrlp: "‚Ü¨", rarrpl: "‚•Ö", rarrsim: "‚•¥", Rarrtl: "‚§ñ", rarrtl: "‚Ü£", rarrw: "‚Üù", ratail: "‚§ö", rAtail: "‚§ú", ratio: "‚à∂", rationals: "‚Ñö", rbarr: "‚§ç", rBarr: "‚§è", RBarr: "‚§ê", rbbrk: "‚ù≥", rbrace: "}", rbrack: "]", rbrke: "‚¶å", rbrksld: "‚¶é", rbrkslu: "‚¶ê", Rcaron: "≈ò", rcaron: "≈ô", Rcedil: "≈ñ", rcedil: "≈ó", rceil: "‚åâ", rcub: "}", Rcy: "–†", rcy: "—Ä", rdca: "‚§∑", rdldhar: "‚•©", rdquo: "‚Äù", rdquor: "‚Äù", rdsh: "‚Ü≥", real: "‚Ñú", realine: "‚Ñõ", realpart: "‚Ñú", reals: "‚Ñù", Re: "‚Ñú", rect: "‚ñ≠", reg: "¬Æ", REG: "¬Æ", ReverseElement: "‚àã", ReverseEquilibrium: "‚áã", ReverseUpEquilibrium: "‚•Ø", rfisht: "‚•Ω", rfloor: "‚åã", rfr: "ùîØ", Rfr: "‚Ñú", rHar: "‚•§", rhard: "‚áÅ", rharu: "‚áÄ", rharul: "‚•¨", Rho: "Œ°", rho: "œÅ", rhov: "œ±", RightAngleBracket: "‚ü©", RightArrowBar: "‚á•", rightarrow: "‚Üí", RightArrow: "‚Üí", Rightarrow: "‚áí", RightArrowLeftArrow: "‚áÑ", rightarrowtail: "‚Ü£", RightCeiling: "‚åâ", RightDoubleBracket: "‚üß", RightDownTeeVector: "‚•ù", RightDownVectorBar: "‚•ï", RightDownVector: "‚áÇ", RightFloor: "‚åã", rightharpoondown: "‚áÅ", rightharpoonup: "‚áÄ", rightleftarrows: "‚áÑ", rightleftharpoons: "‚áå", rightrightarrows: "‚áâ", rightsquigarrow: "‚Üù", RightTeeArrow: "‚Ü¶", RightTee: "‚ä¢", RightTeeVector: "‚•õ", rightthreetimes: "‚ãå", RightTriangleBar: "‚ßê", RightTriangle: "‚ä≥", RightTriangleEqual: "‚äµ", RightUpDownVector: "‚•è", RightUpTeeVector: "‚•ú", RightUpVectorBar: "‚•î", RightUpVector: "‚Üæ", RightVectorBar: "‚•ì", RightVector: "‚áÄ", ring: "Àö", risingdotseq: "‚âì", rlarr: "‚áÑ", rlhar: "‚áå", rlm: "‚Äè", rmoustache: "‚é±", rmoust: "‚é±", rnmid: "‚´Æ", roang: "‚ü≠", roarr: "‚áæ", robrk: "‚üß", ropar: "‚¶Ü", ropf: "ùï£", Ropf: "‚Ñù", roplus: "‚®Æ", rotimes: "‚®µ", RoundImplies: "‚•∞", rpar: ")", rpargt: "‚¶î", rppolint: "‚®í", rrarr: "‚áâ", Rrightarrow: "‚áõ", rsaquo: "‚Ä∫", rscr: "ùìá", Rscr: "‚Ñõ", rsh: "‚Ü±", Rsh: "‚Ü±", rsqb: "]", rsquo: "‚Äô", rsquor: "‚Äô", rthree: "‚ãå", rtimes: "‚ãä", rtri: "‚ñπ", rtrie: "‚äµ", rtrif: "‚ñ∏", rtriltri: "‚ßé", RuleDelayed: "‚ß¥", ruluhar: "‚•®", rx: "‚Ñû", Sacute: "≈ö", sacute: "≈õ", sbquo: "‚Äö", scap: "‚™∏", Scaron: "≈†", scaron: "≈°", Sc: "‚™º", sc: "‚âª", sccue: "‚âΩ", sce: "‚™∞", scE: "‚™¥", Scedil: "≈û", scedil: "≈ü", Scirc: "≈ú", scirc: "≈ù", scnap: "‚™∫", scnE: "‚™∂", scnsim: "‚ã©", scpolint: "‚®ì", scsim: "‚âø", Scy: "–°", scy: "—Å", sdotb: "‚ä°", sdot: "‚ãÖ", sdote: "‚©¶", searhk: "‚§•", searr: "‚Üò", seArr: "‚áò", searrow: "‚Üò", sect: "¬ß", semi: ";", seswar: "‚§©", setminus: "‚àñ", setmn: "‚àñ", sext: "‚ú∂", Sfr: "ùîñ", sfr: "ùî∞", sfrown: "‚å¢", sharp: "‚ôØ", SHCHcy: "–©", shchcy: "—â", SHcy: "–®", shcy: "—à", ShortDownArrow: "‚Üì", ShortLeftArrow: "‚Üê", shortmid: "‚à£", shortparallel: "‚à•", ShortRightArrow: "‚Üí", ShortUpArrow: "‚Üë", shy: "¬≠", Sigma: "Œ£", sigma: "œÉ", sigmaf: "œÇ", sigmav: "œÇ", sim: "‚àº", simdot: "‚©™", sime: "‚âÉ", simeq: "‚âÉ", simg: "‚™û", simgE: "‚™†", siml: "‚™ù", simlE: "‚™ü", simne: "‚âÜ", simplus: "‚®§", simrarr: "‚•≤", slarr: "‚Üê", SmallCircle: "‚àò", smallsetminus: "‚àñ", smashp: "‚®≥", smeparsl: "‚ß§", smid: "‚à£", smile: "‚å£", smt: "‚™™", smte: "‚™¨", smtes: "‚™¨Ô∏Ä", SOFTcy: "–¨", softcy: "—å", solbar: "‚åø", solb: "‚ßÑ", sol: "/", Sopf: "ùïä", sopf: "ùï§", spades: "‚ô†", spadesuit: "‚ô†", spar: "‚à•", sqcap: "‚äì", sqcaps: "‚äìÔ∏Ä", sqcup: "‚äî", sqcups: "‚äîÔ∏Ä", Sqrt: "‚àö", sqsub: "‚äè", sqsube: "‚äë", sqsubset: "‚äè", sqsubseteq: "‚äë", sqsup: "‚äê", sqsupe: "‚äí", sqsupset: "‚äê", sqsupseteq: "‚äí", square: "‚ñ°", Square: "‚ñ°", SquareIntersection: "‚äì", SquareSubset: "‚äè", SquareSubsetEqual: "‚äë", SquareSuperset: "‚äê", SquareSupersetEqual: "‚äí", SquareUnion: "‚äî", squarf: "‚ñ™", squ: "‚ñ°", squf: "‚ñ™", srarr: "‚Üí", Sscr: "ùíÆ", sscr: "ùìà", ssetmn: "‚àñ", ssmile: "‚å£", sstarf: "‚ãÜ", Star: "‚ãÜ", star: "‚òÜ", starf: "‚òÖ", straightepsilon: "œµ", straightphi: "œï", strns: "¬Ø", sub: "‚äÇ", Sub: "‚ãê", subdot: "‚™Ω", subE: "‚´Ö", sube: "‚äÜ", subedot: "‚´É", submult: "‚´Å", subnE: "‚´ã", subne: "‚ää", subplus: "‚™ø", subrarr: "‚•π", subset: "‚äÇ", Subset: "‚ãê", subseteq: "‚äÜ", subseteqq: "‚´Ö", SubsetEqual: "‚äÜ", subsetneq: "‚ää", subsetneqq: "‚´ã", subsim: "‚´á", subsub: "‚´ï", subsup: "‚´ì", succapprox: "‚™∏", succ: "‚âª", succcurlyeq: "‚âΩ", Succeeds: "‚âª", SucceedsEqual: "‚™∞", SucceedsSlantEqual: "‚âΩ", SucceedsTilde: "‚âø", succeq: "‚™∞", succnapprox: "‚™∫", succneqq: "‚™∂", succnsim: "‚ã©", succsim: "‚âø", SuchThat: "‚àã", sum: "‚àë", Sum: "‚àë", sung: "‚ô™", sup1: "¬π", sup2: "¬≤", sup3: "¬≥", sup: "‚äÉ", Sup: "‚ãë", supdot: "‚™æ", supdsub: "‚´ò", supE: "‚´Ü", supe: "‚äá", supedot: "‚´Ñ", Superset: "‚äÉ", SupersetEqual: "‚äá", suphsol: "‚üâ", suphsub: "‚´ó", suplarr: "‚•ª", supmult: "‚´Ç", supnE: "‚´å", supne: "‚äã", supplus: "‚´Ä", supset: "‚äÉ", Supset: "‚ãë", supseteq: "‚äá", supseteqq: "‚´Ü", supsetneq: "‚äã", supsetneqq: "‚´å", supsim: "‚´à", supsub: "‚´î", supsup: "‚´ñ", swarhk: "‚§¶", swarr: "‚Üô", swArr: "‚áô", swarrow: "‚Üô", swnwar: "‚§™", szlig: "√ü", Tab: "	", target: "‚åñ", Tau: "Œ§", tau: "œÑ", tbrk: "‚é¥", Tcaron: "≈§", tcaron: "≈•", Tcedil: "≈¢", tcedil: "≈£", Tcy: "–¢", tcy: "—Ç", tdot: "‚Éõ", telrec: "‚åï", Tfr: "ùîó", tfr: "ùî±", there4: "‚à¥", therefore: "‚à¥", Therefore: "‚à¥", Theta: "Œò", theta: "Œ∏", thetasym: "œë", thetav: "œë", thickapprox: "‚âà", thicksim: "‚àº", ThickSpace: "‚Åü‚Ää", ThinSpace: "‚Äâ", thinsp: "‚Äâ", thkap: "‚âà", thksim: "‚àº", THORN: "√û", thorn: "√æ", tilde: "Àú", Tilde: "‚àº", TildeEqual: "‚âÉ", TildeFullEqual: "‚âÖ", TildeTilde: "‚âà", timesbar: "‚®±", timesb: "‚ä†", times: "√ó", timesd: "‚®∞", tint: "‚à≠", toea: "‚§®", topbot: "‚å∂", topcir: "‚´±", top: "‚ä§", Topf: "ùïã", topf: "ùï•", topfork: "‚´ö", tosa: "‚§©", tprime: "‚Ä¥", trade: "‚Ñ¢", TRADE: "‚Ñ¢", triangle: "‚ñµ", triangledown: "‚ñø", triangleleft: "‚óÉ", trianglelefteq: "‚ä¥", triangleq: "‚âú", triangleright: "‚ñπ", trianglerighteq: "‚äµ", tridot: "‚ó¨", trie: "‚âú", triminus: "‚®∫", TripleDot: "‚Éõ", triplus: "‚®π", trisb: "‚ßç", tritime: "‚®ª", trpezium: "‚è¢", Tscr: "ùíØ", tscr: "ùìâ", TScy: "–¶", tscy: "—Ü", TSHcy: "–ã", tshcy: "—õ", Tstrok: "≈¶", tstrok: "≈ß", twixt: "‚â¨", twoheadleftarrow: "‚Üû", twoheadrightarrow: "‚Ü†", Uacute: "√ö", uacute: "√∫", uarr: "‚Üë", Uarr: "‚Üü", uArr: "‚áë", Uarrocir: "‚•â", Ubrcy: "–é", ubrcy: "—û", Ubreve: "≈¨", ubreve: "≈≠", Ucirc: "√õ", ucirc: "√ª", Ucy: "–£", ucy: "—É", udarr: "‚áÖ", Udblac: "≈∞", udblac: "≈±", udhar: "‚•Æ", ufisht: "‚•æ", Ufr: "ùîò", ufr: "ùî≤", Ugrave: "√ô", ugrave: "√π", uHar: "‚•£", uharl: "‚Üø", uharr: "‚Üæ", uhblk: "‚ñÄ", ulcorn: "‚åú", ulcorner: "‚åú", ulcrop: "‚åè", ultri: "‚ó∏", Umacr: "≈™", umacr: "≈´", uml: "¬®", UnderBar: "_", UnderBrace: "‚èü", UnderBracket: "‚éµ", UnderParenthesis: "‚èù", Union: "‚ãÉ", UnionPlus: "‚äé", Uogon: "≈≤", uogon: "≈≥", Uopf: "ùïå", uopf: "ùï¶", UpArrowBar: "‚§í", uparrow: "‚Üë", UpArrow: "‚Üë", Uparrow: "‚áë", UpArrowDownArrow: "‚áÖ", updownarrow: "‚Üï", UpDownArrow: "‚Üï", Updownarrow: "‚áï", UpEquilibrium: "‚•Æ", upharpoonleft: "‚Üø", upharpoonright: "‚Üæ", uplus: "‚äé", UpperLeftArrow: "‚Üñ", UpperRightArrow: "‚Üó", upsi: "œÖ", Upsi: "œí", upsih: "œí", Upsilon: "Œ•", upsilon: "œÖ", UpTeeArrow: "‚Ü•", UpTee: "‚ä•", upuparrows: "‚áà", urcorn: "‚åù", urcorner: "‚åù", urcrop: "‚åé", Uring: "≈Æ", uring: "≈Ø", urtri: "‚óπ", Uscr: "ùí∞", uscr: "ùìä", utdot: "‚ã∞", Utilde: "≈®", utilde: "≈©", utri: "‚ñµ", utrif: "‚ñ¥", uuarr: "‚áà", Uuml: "√ú", uuml: "√º", uwangle: "‚¶ß", vangrt: "‚¶ú", varepsilon: "œµ", varkappa: "œ∞", varnothing: "‚àÖ", varphi: "œï", varpi: "œñ", varpropto: "‚àù", varr: "‚Üï", vArr: "‚áï", varrho: "œ±", varsigma: "œÇ", varsubsetneq: "‚ääÔ∏Ä", varsubsetneqq: "‚´ãÔ∏Ä", varsupsetneq: "‚äãÔ∏Ä", varsupsetneqq: "‚´åÔ∏Ä", vartheta: "œë", vartriangleleft: "‚ä≤", vartriangleright: "‚ä≥", vBar: "‚´®", Vbar: "‚´´", vBarv: "‚´©", Vcy: "–í", vcy: "–≤", vdash: "‚ä¢", vDash: "‚ä®", Vdash: "‚ä©", VDash: "‚ä´", Vdashl: "‚´¶", veebar: "‚äª", vee: "‚à®", Vee: "‚ãÅ", veeeq: "‚âö", vellip: "‚ãÆ", verbar: "|", Verbar: "‚Äñ", vert: "|", Vert: "‚Äñ", VerticalBar: "‚à£", VerticalLine: "|", VerticalSeparator: "‚ùò", VerticalTilde: "‚âÄ", VeryThinSpace: "‚Ää", Vfr: "ùîô", vfr: "ùî≥", vltri: "‚ä≤", vnsub: "‚äÇ‚Éí", vnsup: "‚äÉ‚Éí", Vopf: "ùïç", vopf: "ùïß", vprop: "‚àù", vrtri: "‚ä≥", Vscr: "ùí±", vscr: "ùìã", vsubnE: "‚´ãÔ∏Ä", vsubne: "‚ääÔ∏Ä", vsupnE: "‚´åÔ∏Ä", vsupne: "‚äãÔ∏Ä", Vvdash: "‚ä™", vzigzag: "‚¶ö", Wcirc: "≈¥", wcirc: "≈µ", wedbar: "‚©ü", wedge: "‚àß", Wedge: "‚ãÄ", wedgeq: "‚âô", weierp: "‚Ñò", Wfr: "ùîö", wfr: "ùî¥", Wopf: "ùïé", wopf: "ùï®", wp: "‚Ñò", wr: "‚âÄ", wreath: "‚âÄ", Wscr: "ùí≤", wscr: "ùìå", xcap: "‚ãÇ", xcirc: "‚óØ", xcup: "‚ãÉ", xdtri: "‚ñΩ", Xfr: "ùîõ", xfr: "ùîµ", xharr: "‚ü∑", xhArr: "‚ü∫", Xi: "Œû", xi: "Œæ", xlarr: "‚üµ", xlArr: "‚ü∏", xmap: "‚üº", xnis: "‚ãª", xodot: "‚®Ä", Xopf: "ùïè", xopf: "ùï©", xoplus: "‚®Å", xotime: "‚®Ç", xrarr: "‚ü∂", xrArr: "‚üπ", Xscr: "ùí≥", xscr: "ùìç", xsqcup: "‚®Ü", xuplus: "‚®Ñ", xutri: "‚ñ≥", xvee: "‚ãÅ", xwedge: "‚ãÄ", Yacute: "√ù", yacute: "√Ω", YAcy: "–Ø", yacy: "—è", Ycirc: "≈∂", ycirc: "≈∑", Ycy: "–´", ycy: "—ã", yen: "¬•", Yfr: "ùîú", yfr: "ùî∂", YIcy: "–á", yicy: "—ó", Yopf: "ùïê", yopf: "ùï™", Yscr: "ùí¥", yscr: "ùìé", YUcy: "–Æ", yucy: "—é", yuml: "√ø", Yuml: "≈∏", Zacute: "≈π", zacute: "≈∫", Zcaron: "≈Ω", zcaron: "≈æ", Zcy: "–ó", zcy: "–∑", Zdot: "≈ª", zdot: "≈º", zeetrf: "‚Ñ®", ZeroWidthSpace: "‚Äã", Zeta: "Œñ", zeta: "Œ∂", zfr: "ùî∑", Zfr: "‚Ñ®", ZHcy: "–ñ", zhcy: "–∂", zigrarr: "‚áù", zopf: "ùï´", Zopf: "‚Ñ§", Zscr: "ùíµ", zscr: "ùìè", zwj: "‚Äç", zwnj: "‚Äå"
	}, lt = /[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4E\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDF55-\uDF59]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD806[\uDC3B\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/, xe = {}, gn = {}; function Ko(t) { var e, n, r = gn[t]; if (r) return r; for (r = gn[t] = [], e = 0; e < 128; e++)n = String.fromCharCode(e), /^[0-9a-z]$/i.test(n) ? r.push(n) : r.push("%" + ("0" + e.toString(16).toUpperCase()).slice(-2)); for (e = 0; e < t.length; e++)r[t.charCodeAt(e)] = t[e]; return r } function Fe(t, e, n) { var r, o, s, i, c, a = ""; for (typeof e != "string" && (n = e, e = Fe.defaultChars), typeof n > "u" && (n = !0), c = Ko(e), r = 0, o = t.length; r < o; r++) { if (s = t.charCodeAt(r), n && s === 37 && r + 2 < o && /^[0-9a-f]{2}$/i.test(t.slice(r + 1, r + 3))) { a += t.slice(r, r + 3), r += 2; continue } if (s < 128) { a += c[s]; continue } if (s >= 55296 && s <= 57343) { if (s >= 55296 && s <= 56319 && r + 1 < o && (i = t.charCodeAt(r + 1), i >= 56320 && i <= 57343)) { a += encodeURIComponent(t[r] + t[r + 1]), r++; continue } a += "%EF%BF%BD"; continue } a += encodeURIComponent(t[r]) } return a } Fe.defaultChars = ";/?:@&=+$,-_.!~*'()#", Fe.componentChars = "-_.!~*'()"; var Jo = Fe, mn = {}; function Yo(t) { var e, n, r = mn[t]; if (r) return r; for (r = mn[t] = [], e = 0; e < 128; e++)n = String.fromCharCode(e), r.push(n); for (e = 0; e < t.length; e++)n = t.charCodeAt(e), r[n] = "%" + ("0" + n.toString(16).toUpperCase()).slice(-2); return r } function Pe(t, e) { var n; return typeof e != "string" && (e = Pe.defaultChars), n = Yo(e), t.replace(/(%[a-f0-9]{2})+/gi, function (r) { var o, s, i, c, a, l, u, d = ""; for (o = 0, s = r.length; o < s; o += 3) { if (i = parseInt(r.slice(o + 1, o + 3), 16), i < 128) { d += n[i]; continue } if ((i & 224) === 192 && o + 3 < s && (c = parseInt(r.slice(o + 4, o + 6), 16), (c & 192) === 128)) { u = i << 6 & 1984 | c & 63, u < 128 ? d += "ÔøΩÔøΩ" : d += String.fromCharCode(u), o += 3; continue } if ((i & 240) === 224 && o + 6 < s && (c = parseInt(r.slice(o + 4, o + 6), 16), a = parseInt(r.slice(o + 7, o + 9), 16), (c & 192) === 128 && (a & 192) === 128)) { u = i << 12 & 61440 | c << 6 & 4032 | a & 63, u < 2048 || u >= 55296 && u <= 57343 ? d += "ÔøΩÔøΩÔøΩ" : d += String.fromCharCode(u), o += 6; continue } if ((i & 248) === 240 && o + 9 < s && (c = parseInt(r.slice(o + 4, o + 6), 16), a = parseInt(r.slice(o + 7, o + 9), 16), l = parseInt(r.slice(o + 10, o + 12), 16), (c & 192) === 128 && (a & 192) === 128 && (l & 192) === 128)) { u = i << 18 & 1835008 | c << 12 & 258048 | a << 6 & 4032 | l & 63, u < 65536 || u > 1114111 ? d += "ÔøΩÔøΩÔøΩÔøΩ" : (u -= 65536, d += String.fromCharCode(55296 + (u >> 10), 56320 + (u & 1023))), o += 9; continue } d += "ÔøΩ" } return d }) } Pe.defaultChars = ";/?:@&=+$,#", Pe.componentChars = ""; var Xo = Pe, Qo = function (e) { var n = ""; return n += e.protocol || "", n += e.slashes ? "//" : "", n += e.auth ? e.auth + "@" : "", e.hostname && e.hostname.indexOf(":") !== -1 ? n += "[" + e.hostname + "]" : n += e.hostname || "", n += e.port ? ":" + e.port : "", n += e.pathname || "", n += e.search || "", n += e.hash || "", n }; function ze() { this.protocol = null, this.slashes = null, this.auth = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.pathname = null } var es = /^([a-z0-9.+-]+:)/i, ts = /:[0-9]*$/, ns = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, rs = ["<", ">", '"', "`", " ", "\r", `
`, "	"], os = ["{", "}", "|", "\\", "^", "`"].concat(rs), ss = ["'"].concat(os), bn = ["%", "/", "?", ";", "#"].concat(ss), _n = ["/", "?", "#"], cs = 255, kn = /^[+a-z0-9A-Z_-]{0,63}$/, is = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, xn = { javascript: !0, "javascript:": !0 }, wn = { http: !0, https: !0, ftp: !0, gopher: !0, file: !0, "http:": !0, "https:": !0, "ftp:": !0, "gopher:": !0, "file:": !0 }; function as(t, e) { if (t && t instanceof ze) return t; var n = new ze; return n.parse(t, e), n } ze.prototype.parse = function (t, e) { var n, r, o, s, i, c = t; if (c = c.trim(), !e && t.split("#").length === 1) { var a = ns.exec(c); if (a) return this.pathname = a[1], a[2] && (this.search = a[2]), this } var l = es.exec(c); if (l && (l = l[0], o = l.toLowerCase(), this.protocol = l, c = c.substr(l.length)), (e || l || c.match(/^\/\/[^@\/]+@[^@\/]+/)) && (i = c.substr(0, 2) === "//", i && !(l && xn[l]) && (c = c.substr(2), this.slashes = !0)), !xn[l] && (i || l && !wn[l])) { var u = -1; for (n = 0; n < _n.length; n++)s = c.indexOf(_n[n]), s !== -1 && (u === -1 || s < u) && (u = s); var d, f; for (u === -1 ? f = c.lastIndexOf("@") : f = c.lastIndexOf("@", u), f !== -1 && (d = c.slice(0, f), c = c.slice(f + 1), this.auth = d), u = -1, n = 0; n < bn.length; n++)s = c.indexOf(bn[n]), s !== -1 && (u === -1 || s < u) && (u = s); u === -1 && (u = c.length), c[u - 1] === ":" && u--; var h = c.slice(0, u); c = c.slice(u), this.parseHost(h), this.hostname = this.hostname || ""; var m = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]"; if (!m) { var x = this.hostname.split(/\./); for (n = 0, r = x.length; n < r; n++) { var C = x[n]; if (C && !C.match(kn)) { for (var v = "", b = 0, E = C.length; b < E; b++)C.charCodeAt(b) > 127 ? v += "x" : v += C[b]; if (!v.match(kn)) { var q = x.slice(0, n), T = x.slice(n + 1), k = C.match(is); k && (q.push(k[1]), T.unshift(k[2])), T.length && (c = T.join(".") + c), this.hostname = q.join("."); break } } } } this.hostname.length > cs && (this.hostname = ""), m && (this.hostname = this.hostname.substr(1, this.hostname.length - 2)) } var B = c.indexOf("#"); B !== -1 && (this.hash = c.substr(B), c = c.slice(0, B)); var U = c.indexOf("?"); return U !== -1 && (this.search = c.substr(U), c = c.slice(0, U)), c && (this.pathname = c), wn[o] && this.hostname && !this.pathname && (this.pathname = ""), this }, ze.prototype.parseHost = function (t) { var e = ts.exec(t); e && (e = e[0], e !== ":" && (this.port = e.substr(1)), t = t.substr(0, t.length - e.length)), t && (this.hostname = t) }; var ls = as; xe.encode = Jo, xe.decode = Xo, xe.format = Qo, xe.parse = ls; var de = {}, ut, yn; function vn() { return yn || (yn = 1, ut = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/), ut } var pt, En; function An() { return En || (En = 1, pt = /[\0-\x1F\x7F-\x9F]/), pt } var ft, Cn; function us() { return Cn || (Cn = 1, ft = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804[\uDCBD\uDCCD]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/), ft } var ht, qn; function Sn() { return qn || (qn = 1, ht = /[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/), ht } var Dn; function ps() { return Dn || (Dn = 1, de.Any = vn(), de.Cc = An(), de.Cf = us(), de.P = lt, de.Z = Sn()), de } (function (t) { function e(_) { return Object.prototype.toString.call(_) } function n(_) { return e(_) === "[object String]" } var r = Object.prototype.hasOwnProperty; function o(_, O) { return r.call(_, O) } function s(_) { var O = Array.prototype.slice.call(arguments, 1); return O.forEach(function (L) { if (L) { if (typeof L != "object") throw new TypeError(L + "must be object"); Object.keys(L).forEach(function (g) { _[g] = L[g] }) } }), _ } function i(_, O, L) { return [].concat(_.slice(0, O), L, _.slice(O + 1)) } function c(_) { return !(_ >= 55296 && _ <= 57343 || _ >= 64976 && _ <= 65007 || (_ & 65535) === 65535 || (_ & 65535) === 65534 || _ >= 0 && _ <= 8 || _ === 11 || _ >= 14 && _ <= 31 || _ >= 127 && _ <= 159 || _ > 1114111) } function a(_) { if (_ > 65535) { _ -= 65536; var O = 55296 + (_ >> 10), L = 56320 + (_ & 1023); return String.fromCharCode(O, L) } return String.fromCharCode(_) } var l = /\\([!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~])/g, u = /&([a-z#][a-z0-9]{1,31});/gi, d = new RegExp(l.source + "|" + u.source, "gi"), f = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))/i, h = dn; function m(_, O) { var L = 0; return o(h, O) ? h[O] : O.charCodeAt(0) === 35 && f.test(O) && (L = O[1].toLowerCase() === "x" ? parseInt(O.slice(2), 16) : parseInt(O.slice(1), 10), c(L)) ? a(L) : _ } function x(_) { return _.indexOf("\\") < 0 ? _ : _.replace(l, "$1") } function C(_) { return _.indexOf("\\") < 0 && _.indexOf("&") < 0 ? _ : _.replace(d, function (O, L, g) { return L || m(O, g) }) } var v = /[&<>"]/, b = /[&<>"]/g, E = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;" }; function q(_) { return E[_] } function T(_) { return v.test(_) ? _.replace(b, q) : _ } var k = /[.?*+^$[\]\\(){}|-]/g; function B(_) { return _.replace(k, "\\$&") } function U(_) { switch (_) { case 9: case 32: return !0 }return !1 } function G(_) { if (_ >= 8192 && _ <= 8202) return !0; switch (_) { case 9: case 10: case 11: case 12: case 13: case 32: case 160: case 5760: case 8239: case 8287: case 12288: return !0 }return !1 } var N = lt; function P(_) { return N.test(_) } function ce(_) { switch (_) { case 33: case 34: case 35: case 36: case 37: case 38: case 39: case 40: case 41: case 42: case 43: case 44: case 45: case 46: case 47: case 58: case 59: case 60: case 61: case 62: case 63: case 64: case 91: case 92: case 93: case 94: case 95: case 96: case 123: case 124: case 125: case 126: return !0; default: return !1 } } function re(_) { return _ = _.trim().replace(/\s+/g, " "), "·∫û".toLowerCase() === "·πæ" && (_ = _.replace(/·∫û/g, "√ü")), _.toLowerCase().toUpperCase() } t.lib = {}, t.lib.mdurl = xe, t.lib.ucmicro = ps(), t.assign = s, t.isString = n, t.has = o, t.unescapeMd = x, t.unescapeAll = C, t.isValidEntityCode = c, t.fromCodePoint = a, t.escapeHtml = T, t.arrayReplaceAt = i, t.isSpace = U, t.isWhiteSpace = G, t.isMdAsciiPunct = ce, t.isPunctChar = P, t.escapeRE = B, t.normalizeReference = re })(I); var Ue = {}, fs = function (e, n, r) { var o, s, i, c, a = -1, l = e.posMax, u = e.pos; for (e.pos = n + 1, o = 1; e.pos < l;) { if (i = e.src.charCodeAt(e.pos), i === 93 && (o--, o === 0)) { s = !0; break } if (c = e.pos, e.md.inline.skipToken(e), i === 91) { if (c === e.pos - 1) o++; else if (r) return e.pos = u, -1 } } return s && (a = e.pos), e.pos = u, a }, Tn = I.unescapeAll, hs = function (e, n, r) { var o, s, i = 0, c = n, a = { ok: !1, pos: 0, lines: 0, str: "" }; if (e.charCodeAt(n) === 60) { for (n++; n < r;) { if (o = e.charCodeAt(n), o === 10 || o === 60) return a; if (o === 62) return a.pos = n + 1, a.str = Tn(e.slice(c + 1, n)), a.ok = !0, a; if (o === 92 && n + 1 < r) { n += 2; continue } n++ } return a } for (s = 0; n < r && (o = e.charCodeAt(n), !(o === 32 || o < 32 || o === 127));) { if (o === 92 && n + 1 < r) { if (e.charCodeAt(n + 1) === 32) break; n += 2; continue } if (o === 40 && (s++, s > 32)) return a; if (o === 41) { if (s === 0) break; s-- } n++ } return c === n || s !== 0 || (a.str = Tn(e.slice(c, n)), a.lines = i, a.pos = n, a.ok = !0), a }, ds = I.unescapeAll, gs = function (e, n, r) { var o, s, i = 0, c = n, a = { ok: !1, pos: 0, lines: 0, str: "" }; if (n >= r || (s = e.charCodeAt(n), s !== 34 && s !== 39 && s !== 40)) return a; for (n++, s === 40 && (s = 41); n < r;) { if (o = e.charCodeAt(n), o === s) return a.pos = n + 1, a.lines = i, a.str = ds(e.slice(c + 1, n)), a.ok = !0, a; if (o === 40 && s === 41) return a; o === 10 ? i++ : o === 92 && n + 1 < r && (n++, e.charCodeAt(n) === 10 && i++), n++ } return a }; Ue.parseLinkLabel = fs, Ue.parseLinkDestination = hs, Ue.parseLinkTitle = gs; var ms = I.assign, bs = I.unescapeAll, ge = I.escapeHtml, Q = {}; Q.code_inline = function (t, e, n, r, o) { var s = t[e]; return "<code" + o.renderAttrs(s) + ">" + ge(t[e].content) + "</code>" }, Q.code_block = function (t, e, n, r, o) {
		var s = t[e]; return "<pre" + o.renderAttrs(s) + "><code>" + ge(t[e].content) + `</code></pre>
`}, Q.fence = function (t, e, n, r, o) {
			var s = t[e], i = s.info ? bs(s.info).trim() : "", c = "", a = "", l, u, d, f, h; return i && (d = i.split(/(\s+)/g), c = d[0], a = d.slice(2).join("")), n.highlight ? l = n.highlight(s.content, c, a) || ge(s.content) : l = ge(s.content), l.indexOf("<pre") === 0 ? l + `
`: i ? (u = s.attrIndex("class"), f = s.attrs ? s.attrs.slice() : [], u < 0 ? f.push(["class", n.langPrefix + c]) : (f[u] = f[u].slice(), f[u][1] += " " + n.langPrefix + c), h = { attrs: f }, "<pre><code" + o.renderAttrs(h) + ">" + l + `</code></pre>
`) : "<pre><code" + o.renderAttrs(s) + ">" + l + `</code></pre>
`}, Q.image = function (t, e, n, r, o) { var s = t[e]; return s.attrs[s.attrIndex("alt")][1] = o.renderInlineAsText(s.children, n, r), o.renderToken(t, e, n) }, Q.hardbreak = function (t, e, n) {
			return n.xhtmlOut ? `<br />
`: `<br>
`}, Q.softbreak = function (t, e, n) {
			return n.breaks ? n.xhtmlOut ? `<br />
`: `<br>
`: `
`}, Q.text = function (t, e) { return ge(t[e].content) }, Q.html_block = function (t, e) { return t[e].content }, Q.html_inline = function (t, e) { return t[e].content }; function we() { this.rules = ms({}, Q) } we.prototype.renderAttrs = function (e) { var n, r, o; if (!e.attrs) return ""; for (o = "", n = 0, r = e.attrs.length; n < r; n++)o += " " + ge(e.attrs[n][0]) + '="' + ge(e.attrs[n][1]) + '"'; return o }, we.prototype.renderToken = function (e, n, r) {
		var o, s = "", i = !1, c = e[n]; return c.hidden ? "" : (c.block && c.nesting !== -1 && n && e[n - 1].hidden && (s += `
`), s += (c.nesting === -1 ? "</" : "<") + c.tag, s += this.renderAttrs(c), c.nesting === 0 && r.xhtmlOut && (s += " /"), c.block && (i = !0, c.nesting === 1 && n + 1 < e.length && (o = e[n + 1], (o.type === "inline" || o.hidden || o.nesting === -1 && o.tag === c.tag) && (i = !1))), s += i ? `>
`: ">", s)
	}, we.prototype.renderInline = function (t, e, n) { for (var r, o = "", s = this.rules, i = 0, c = t.length; i < c; i++)r = t[i].type, typeof s[r] < "u" ? o += s[r](t, i, e, n, this) : o += this.renderToken(t, i, e); return o }, we.prototype.renderInlineAsText = function (t, e, n) {
		for (var r = "", o = 0, s = t.length; o < s; o++)t[o].type === "text" ? r += t[o].content : t[o].type === "image" ? r += this.renderInlineAsText(t[o].children, e, n) : t[o].type === "softbreak" && (r += `
`); return r
	}, we.prototype.render = function (t, e, n) { var r, o, s, i = "", c = this.rules; for (r = 0, o = t.length; r < o; r++)s = t[r].type, s === "inline" ? i += this.renderInline(t[r].children, e, n) : typeof c[s] < "u" ? i += c[t[r].type](t, r, e, n, this) : i += this.renderToken(t, r, e, n); return i }; var _s = we; function Y() { this.__rules__ = [], this.__cache__ = null } Y.prototype.__find__ = function (t) { for (var e = 0; e < this.__rules__.length; e++)if (this.__rules__[e].name === t) return e; return -1 }, Y.prototype.__compile__ = function () { var t = this, e = [""]; t.__rules__.forEach(function (n) { n.enabled && n.alt.forEach(function (r) { e.indexOf(r) < 0 && e.push(r) }) }), t.__cache__ = {}, e.forEach(function (n) { t.__cache__[n] = [], t.__rules__.forEach(function (r) { r.enabled && (n && r.alt.indexOf(n) < 0 || t.__cache__[n].push(r.fn)) }) }) }, Y.prototype.at = function (t, e, n) { var r = this.__find__(t), o = n || {}; if (r === -1) throw new Error("Parser rule not found: " + t); this.__rules__[r].fn = e, this.__rules__[r].alt = o.alt || [], this.__cache__ = null }, Y.prototype.before = function (t, e, n, r) { var o = this.__find__(t), s = r || {}; if (o === -1) throw new Error("Parser rule not found: " + t); this.__rules__.splice(o, 0, { name: e, enabled: !0, fn: n, alt: s.alt || [] }), this.__cache__ = null }, Y.prototype.after = function (t, e, n, r) { var o = this.__find__(t), s = r || {}; if (o === -1) throw new Error("Parser rule not found: " + t); this.__rules__.splice(o + 1, 0, { name: e, enabled: !0, fn: n, alt: s.alt || [] }), this.__cache__ = null }, Y.prototype.push = function (t, e, n) { var r = n || {}; this.__rules__.push({ name: t, enabled: !0, fn: e, alt: r.alt || [] }), this.__cache__ = null }, Y.prototype.enable = function (t, e) { Array.isArray(t) || (t = [t]); var n = []; return t.forEach(function (r) { var o = this.__find__(r); if (o < 0) { if (e) return; throw new Error("Rules manager: invalid rule name " + r) } this.__rules__[o].enabled = !0, n.push(r) }, this), this.__cache__ = null, n }, Y.prototype.enableOnly = function (t, e) { Array.isArray(t) || (t = [t]), this.__rules__.forEach(function (n) { n.enabled = !1 }), this.enable(t, e) }, Y.prototype.disable = function (t, e) { Array.isArray(t) || (t = [t]); var n = []; return t.forEach(function (r) { var o = this.__find__(r); if (o < 0) { if (e) return; throw new Error("Rules manager: invalid rule name " + r) } this.__rules__[o].enabled = !1, n.push(r) }, this), this.__cache__ = null, n }, Y.prototype.getRules = function (t) { return this.__cache__ === null && this.__compile__(), this.__cache__[t] || [] }; var dt = Y, ks = /\r\n?|\n/g, xs = /\0/g, ws = function (e) {
		var n; n = e.src.replace(ks, `
`), n = n.replace(xs, "ÔøΩ"), e.src = n
	}, ys = function (e) { var n; e.inlineMode ? (n = new e.Token("inline", "", 0), n.content = e.src, n.map = [0, 1], n.children = [], e.tokens.push(n)) : e.md.block.parse(e.src, e.md, e.env, e.tokens) }, vs = function (e) { var n = e.tokens, r, o, s; for (o = 0, s = n.length; o < s; o++)r = n[o], r.type === "inline" && e.md.inline.parse(r.content, e.md, e.env, r.children) }, Es = I.arrayReplaceAt; function As(t) { return /^<a[>\s]/i.test(t) } function Cs(t) { return /^<\/a\s*>/i.test(t) } var qs = function (e) { var n, r, o, s, i, c, a, l, u, d, f, h, m, x, C, v, b = e.tokens, E; if (e.md.options.linkify) { for (r = 0, o = b.length; r < o; r++)if (!(b[r].type !== "inline" || !e.md.linkify.pretest(b[r].content))) for (s = b[r].children, m = 0, n = s.length - 1; n >= 0; n--) { if (c = s[n], c.type === "link_close") { for (n--; s[n].level !== c.level && s[n].type !== "link_open";)n--; continue } if (c.type === "html_inline" && (As(c.content) && m > 0 && m--, Cs(c.content) && m++), !(m > 0) && c.type === "text" && e.md.linkify.test(c.content)) { for (u = c.content, E = e.md.linkify.match(u), a = [], h = c.level, f = 0, l = 0; l < E.length; l++)x = E[l].url, C = e.md.normalizeLink(x), e.md.validateLink(C) && (v = E[l].text, E[l].schema ? E[l].schema === "mailto:" && !/^mailto:/i.test(v) ? v = e.md.normalizeLinkText("mailto:" + v).replace(/^mailto:/, "") : v = e.md.normalizeLinkText(v) : v = e.md.normalizeLinkText("http://" + v).replace(/^http:\/\//, ""), d = E[l].index, d > f && (i = new e.Token("text", "", 0), i.content = u.slice(f, d), i.level = h, a.push(i)), i = new e.Token("link_open", "a", 1), i.attrs = [["href", C]], i.level = h++, i.markup = "linkify", i.info = "auto", a.push(i), i = new e.Token("text", "", 0), i.content = v, i.level = h, a.push(i), i = new e.Token("link_close", "a", -1), i.level = --h, i.markup = "linkify", i.info = "auto", a.push(i), f = E[l].lastIndex); f < u.length && (i = new e.Token("text", "", 0), i.content = u.slice(f), i.level = h, a.push(i)), b[r].children = s = Es(s, n, a) } } } }, Rn = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/, Ss = /\((c|tm|r|p)\)/i, Ds = /\((c|tm|r|p)\)/ig, Ts = { c: "¬©", r: "¬Æ", p: "¬ß", tm: "‚Ñ¢" }; function Rs(t, e) { return Ts[e.toLowerCase()] } function Ns(t) { var e, n, r = 0; for (e = t.length - 1; e >= 0; e--)n = t[e], n.type === "text" && !r && (n.content = n.content.replace(Ds, Rs)), n.type === "link_open" && n.info === "auto" && r--, n.type === "link_close" && n.info === "auto" && r++ } function Ls(t) { var e, n, r = 0; for (e = t.length - 1; e >= 0; e--)n = t[e], n.type === "text" && !r && Rn.test(n.content) && (n.content = n.content.replace(/\+-/g, "¬±").replace(/\.{2,}/g, "‚Ä¶").replace(/([?!])‚Ä¶/g, "$1..").replace(/([?!]){4,}/g, "$1$1$1").replace(/,{2,}/g, ",").replace(/(^|[^-])---(?=[^-]|$)/mg, "$1‚Äî").replace(/(^|\s)--(?=\s|$)/mg, "$1‚Äì").replace(/(^|[^-\s])--(?=[^-\s]|$)/mg, "$1‚Äì")), n.type === "link_open" && n.info === "auto" && r--, n.type === "link_close" && n.info === "auto" && r++ } var Bs = function (e) { var n; if (e.md.options.typographer) for (n = e.tokens.length - 1; n >= 0; n--)e.tokens[n].type === "inline" && (Ss.test(e.tokens[n].content) && Ns(e.tokens[n].children), Rn.test(e.tokens[n].content) && Ls(e.tokens[n].children)) }, Nn = I.isWhiteSpace, Ln = I.isPunctChar, Bn = I.isMdAsciiPunct, Ms = /['"]/, Mn = /['"]/g, In = "‚Äô"; function Ve(t, e, n) { return t.substr(0, e) + n + t.substr(e + 1) } function Is(t, e) { var n, r, o, s, i, c, a, l, u, d, f, h, m, x, C, v, b, E, q, T, k; for (q = [], n = 0; n < t.length; n++) { for (r = t[n], a = t[n].level, b = q.length - 1; b >= 0 && !(q[b].level <= a); b--); if (q.length = b + 1, r.type === "text") { o = r.content, i = 0, c = o.length; e: for (; i < c && (Mn.lastIndex = i, s = Mn.exec(o), !!s);) { if (C = v = !0, i = s.index + 1, E = s[0] === "'", u = 32, s.index - 1 >= 0) u = o.charCodeAt(s.index - 1); else for (b = n - 1; b >= 0 && !(t[b].type === "softbreak" || t[b].type === "hardbreak"); b--)if (t[b].content) { u = t[b].content.charCodeAt(t[b].content.length - 1); break } if (d = 32, i < c) d = o.charCodeAt(i); else for (b = n + 1; b < t.length && !(t[b].type === "softbreak" || t[b].type === "hardbreak"); b++)if (t[b].content) { d = t[b].content.charCodeAt(0); break } if (f = Bn(u) || Ln(String.fromCharCode(u)), h = Bn(d) || Ln(String.fromCharCode(d)), m = Nn(u), x = Nn(d), x ? C = !1 : h && (m || f || (C = !1)), m ? v = !1 : f && (x || h || (v = !1)), d === 34 && s[0] === '"' && u >= 48 && u <= 57 && (v = C = !1), C && v && (C = f, v = h), !C && !v) { E && (r.content = Ve(r.content, s.index, In)); continue } if (v) { for (b = q.length - 1; b >= 0 && (l = q[b], !(q[b].level < a)); b--)if (l.single === E && q[b].level === a) { l = q[b], E ? (T = e.md.options.quotes[2], k = e.md.options.quotes[3]) : (T = e.md.options.quotes[0], k = e.md.options.quotes[1]), r.content = Ve(r.content, s.index, k), t[l.token].content = Ve(t[l.token].content, l.pos, T), i += k.length - 1, l.token === n && (i += T.length - 1), o = r.content, c = o.length, q.length = b; continue e } } C ? q.push({ token: n, pos: s.index, single: E, level: a }) : v && E && (r.content = Ve(r.content, s.index, In)) } } } } var Os = function (e) { var n; if (e.md.options.typographer) for (n = e.tokens.length - 1; n >= 0; n--)e.tokens[n].type !== "inline" || !Ms.test(e.tokens[n].content) || Is(e.tokens[n].children, e) }; function ye(t, e, n) { this.type = t, this.tag = e, this.attrs = null, this.map = null, this.nesting = n, this.level = 0, this.children = null, this.content = "", this.markup = "", this.info = "", this.meta = null, this.block = !1, this.hidden = !1 } ye.prototype.attrIndex = function (e) { var n, r, o; if (!this.attrs) return -1; for (n = this.attrs, r = 0, o = n.length; r < o; r++)if (n[r][0] === e) return r; return -1 }, ye.prototype.attrPush = function (e) { this.attrs ? this.attrs.push(e) : this.attrs = [e] }, ye.prototype.attrSet = function (e, n) { var r = this.attrIndex(e), o = [e, n]; r < 0 ? this.attrPush(o) : this.attrs[r] = o }, ye.prototype.attrGet = function (e) { var n = this.attrIndex(e), r = null; return n >= 0 && (r = this.attrs[n][1]), r }, ye.prototype.attrJoin = function (e, n) { var r = this.attrIndex(e); r < 0 ? this.attrPush([e, n]) : this.attrs[r][1] = this.attrs[r][1] + " " + n }; var gt = ye, Fs = gt; function On(t, e, n) { this.src = t, this.env = n, this.tokens = [], this.inlineMode = !1, this.md = e } On.prototype.Token = Fs; var Ps = On, zs = dt, mt = [["normalize", ws], ["block", ys], ["inline", vs], ["linkify", qs], ["replacements", Bs], ["smartquotes", Os]]; function bt() { this.ruler = new zs; for (var t = 0; t < mt.length; t++)this.ruler.push(mt[t][0], mt[t][1]) } bt.prototype.process = function (t) { var e, n, r; for (r = this.ruler.getRules(""), e = 0, n = r.length; e < n; e++)r[e](t) }, bt.prototype.State = Ps; var Us = bt, _t = I.isSpace; function kt(t, e) { var n = t.bMarks[e] + t.tShift[e], r = t.eMarks[e]; return t.src.substr(n, r - n) } function Fn(t) { var e = [], n = 0, r = t.length, o, s = !1, i = 0, c = ""; for (o = t.charCodeAt(n); n < r;)o === 124 && (s ? (c += t.substring(i, n - 1), i = n) : (e.push(c + t.substring(i, n)), c = "", i = n + 1)), s = o === 92, n++, o = t.charCodeAt(n); return e.push(c + t.substring(i)), e } var Vs = function (e, n, r, o) { var s, i, c, a, l, u, d, f, h, m, x, C, v, b, E, q, T, k; if (n + 2 > r || (u = n + 1, e.sCount[u] < e.blkIndent) || e.sCount[u] - e.blkIndent >= 4 || (c = e.bMarks[u] + e.tShift[u], c >= e.eMarks[u]) || (T = e.src.charCodeAt(c++), T !== 124 && T !== 45 && T !== 58) || c >= e.eMarks[u] || (k = e.src.charCodeAt(c++), k !== 124 && k !== 45 && k !== 58 && !_t(k)) || T === 45 && _t(k)) return !1; for (; c < e.eMarks[u];) { if (s = e.src.charCodeAt(c), s !== 124 && s !== 45 && s !== 58 && !_t(s)) return !1; c++ } for (i = kt(e, n + 1), d = i.split("|"), m = [], a = 0; a < d.length; a++) { if (x = d[a].trim(), !x) { if (a === 0 || a === d.length - 1) continue; return !1 } if (!/^:?-+:?$/.test(x)) return !1; x.charCodeAt(x.length - 1) === 58 ? m.push(x.charCodeAt(0) === 58 ? "center" : "right") : x.charCodeAt(0) === 58 ? m.push("left") : m.push("") } if (i = kt(e, n).trim(), i.indexOf("|") === -1 || e.sCount[n] - e.blkIndent >= 4 || (d = Fn(i), d.length && d[0] === "" && d.shift(), d.length && d[d.length - 1] === "" && d.pop(), f = d.length, f === 0 || f !== m.length)) return !1; if (o) return !0; for (b = e.parentType, e.parentType = "table", q = e.md.block.ruler.getRules("blockquote"), h = e.push("table_open", "table", 1), h.map = C = [n, 0], h = e.push("thead_open", "thead", 1), h.map = [n, n + 1], h = e.push("tr_open", "tr", 1), h.map = [n, n + 1], a = 0; a < d.length; a++)h = e.push("th_open", "th", 1), m[a] && (h.attrs = [["style", "text-align:" + m[a]]]), h = e.push("inline", "", 0), h.content = d[a].trim(), h.children = [], h = e.push("th_close", "th", -1); for (h = e.push("tr_close", "tr", -1), h = e.push("thead_close", "thead", -1), u = n + 2; u < r && !(e.sCount[u] < e.blkIndent); u++) { for (E = !1, a = 0, l = q.length; a < l; a++)if (q[a](e, u, r, !0)) { E = !0; break } if (E || (i = kt(e, u).trim(), !i) || e.sCount[u] - e.blkIndent >= 4) break; for (d = Fn(i), d.length && d[0] === "" && d.shift(), d.length && d[d.length - 1] === "" && d.pop(), u === n + 2 && (h = e.push("tbody_open", "tbody", 1), h.map = v = [n + 2, 0]), h = e.push("tr_open", "tr", 1), h.map = [u, u + 1], a = 0; a < f; a++)h = e.push("td_open", "td", 1), m[a] && (h.attrs = [["style", "text-align:" + m[a]]]), h = e.push("inline", "", 0), h.content = d[a] ? d[a].trim() : "", h.children = [], h = e.push("td_close", "td", -1); h = e.push("tr_close", "tr", -1) } return v && (h = e.push("tbody_close", "tbody", -1), v[1] = u), h = e.push("table_close", "table", -1), C[1] = u, e.parentType = b, e.line = u, !0 }, $s = function (e, n, r) {
		var o, s, i; if (e.sCount[n] - e.blkIndent < 4) return !1; for (s = o = n + 1; o < r;) { if (e.isEmpty(o)) { o++; continue } if (e.sCount[o] - e.blkIndent >= 4) { o++, s = o; continue } break } return e.line = s, i = e.push("code_block", "code", 0), i.content = e.getLines(n, s, 4 + e.blkIndent, !1) + `
`, i.map = [n, e.line], !0
	}, Gs = function (e, n, r, o) { var s, i, c, a, l, u, d, f = !1, h = e.bMarks[n] + e.tShift[n], m = e.eMarks[n]; if (e.sCount[n] - e.blkIndent >= 4 || h + 3 > m || (s = e.src.charCodeAt(h), s !== 126 && s !== 96) || (l = h, h = e.skipChars(h, s), i = h - l, i < 3) || (d = e.src.slice(l, h), c = e.src.slice(h, m), s === 96 && c.indexOf(String.fromCharCode(s)) >= 0)) return !1; if (o) return !0; for (a = n; a++, !(a >= r || (h = l = e.bMarks[a] + e.tShift[a], m = e.eMarks[a], h < m && e.sCount[a] < e.blkIndent));)if (e.src.charCodeAt(h) === s && !(e.sCount[a] - e.blkIndent >= 4) && (h = e.skipChars(h, s), !(h - l < i) && (h = e.skipSpaces(h), !(h < m)))) { f = !0; break } return i = e.sCount[n], e.line = a + (f ? 1 : 0), u = e.push("fence", "code", 0), u.info = c, u.content = e.getLines(n + 1, a, i, !0), u.markup = d, u.map = [n, e.line], !0 }, Pn = I.isSpace, Hs = function (e, n, r, o) { var s, i, c, a, l, u, d, f, h, m, x, C, v, b, E, q, T, k, B, U, G = e.lineMax, N = e.bMarks[n] + e.tShift[n], P = e.eMarks[n]; if (e.sCount[n] - e.blkIndent >= 4 || e.src.charCodeAt(N++) !== 62) return !1; if (o) return !0; for (a = h = e.sCount[n] + 1, e.src.charCodeAt(N) === 32 ? (N++, a++, h++, s = !1, q = !0) : e.src.charCodeAt(N) === 9 ? (q = !0, (e.bsCount[n] + h) % 4 === 3 ? (N++, a++, h++, s = !1) : s = !0) : q = !1, m = [e.bMarks[n]], e.bMarks[n] = N; N < P && (i = e.src.charCodeAt(N), Pn(i));) { i === 9 ? h += 4 - (h + e.bsCount[n] + (s ? 1 : 0)) % 4 : h++; N++ } for (x = [e.bsCount[n]], e.bsCount[n] = e.sCount[n] + 1 + (q ? 1 : 0), u = N >= P, b = [e.sCount[n]], e.sCount[n] = h - a, E = [e.tShift[n]], e.tShift[n] = N - e.bMarks[n], k = e.md.block.ruler.getRules("blockquote"), v = e.parentType, e.parentType = "blockquote", f = n + 1; f < r && (U = e.sCount[f] < e.blkIndent, N = e.bMarks[f] + e.tShift[f], P = e.eMarks[f], !(N >= P)); f++) { if (e.src.charCodeAt(N++) === 62 && !U) { for (a = h = e.sCount[f] + 1, e.src.charCodeAt(N) === 32 ? (N++, a++, h++, s = !1, q = !0) : e.src.charCodeAt(N) === 9 ? (q = !0, (e.bsCount[f] + h) % 4 === 3 ? (N++, a++, h++, s = !1) : s = !0) : q = !1, m.push(e.bMarks[f]), e.bMarks[f] = N; N < P && (i = e.src.charCodeAt(N), Pn(i));) { i === 9 ? h += 4 - (h + e.bsCount[f] + (s ? 1 : 0)) % 4 : h++; N++ } u = N >= P, x.push(e.bsCount[f]), e.bsCount[f] = e.sCount[f] + 1 + (q ? 1 : 0), b.push(e.sCount[f]), e.sCount[f] = h - a, E.push(e.tShift[f]), e.tShift[f] = N - e.bMarks[f]; continue } if (u) break; for (T = !1, c = 0, l = k.length; c < l; c++)if (k[c](e, f, r, !0)) { T = !0; break } if (T) { e.lineMax = f, e.blkIndent !== 0 && (m.push(e.bMarks[f]), x.push(e.bsCount[f]), E.push(e.tShift[f]), b.push(e.sCount[f]), e.sCount[f] -= e.blkIndent); break } m.push(e.bMarks[f]), x.push(e.bsCount[f]), E.push(e.tShift[f]), b.push(e.sCount[f]), e.sCount[f] = -1 } for (C = e.blkIndent, e.blkIndent = 0, B = e.push("blockquote_open", "blockquote", 1), B.markup = ">", B.map = d = [n, 0], e.md.block.tokenize(e, n, f), B = e.push("blockquote_close", "blockquote", -1), B.markup = ">", e.lineMax = G, e.parentType = v, d[1] = e.line, c = 0; c < E.length; c++)e.bMarks[c + n] = m[c], e.tShift[c + n] = E[c], e.sCount[c + n] = b[c], e.bsCount[c + n] = x[c]; return e.blkIndent = C, !0 }, js = I.isSpace, Zs = function (e, n, r, o) { var s, i, c, a, l = e.bMarks[n] + e.tShift[n], u = e.eMarks[n]; if (e.sCount[n] - e.blkIndent >= 4 || (s = e.src.charCodeAt(l++), s !== 42 && s !== 45 && s !== 95)) return !1; for (i = 1; l < u;) { if (c = e.src.charCodeAt(l++), c !== s && !js(c)) return !1; c === s && i++ } return i < 3 ? !1 : (o || (e.line = n + 1, a = e.push("hr", "hr", 0), a.map = [n, e.line], a.markup = Array(i + 1).join(String.fromCharCode(s))), !0) }, zn = I.isSpace; function Un(t, e) { var n, r, o, s; return r = t.bMarks[e] + t.tShift[e], o = t.eMarks[e], n = t.src.charCodeAt(r++), n !== 42 && n !== 45 && n !== 43 || r < o && (s = t.src.charCodeAt(r), !zn(s)) ? -1 : r } function Vn(t, e) { var n, r = t.bMarks[e] + t.tShift[e], o = r, s = t.eMarks[e]; if (o + 1 >= s || (n = t.src.charCodeAt(o++), n < 48 || n > 57)) return -1; for (; ;) { if (o >= s) return -1; if (n = t.src.charCodeAt(o++), n >= 48 && n <= 57) { if (o - r >= 10) return -1; continue } if (n === 41 || n === 46) break; return -1 } return o < s && (n = t.src.charCodeAt(o), !zn(n)) ? -1 : o } function Ws(t, e) { var n, r, o = t.level + 2; for (n = e + 2, r = t.tokens.length - 2; n < r; n++)t.tokens[n].level === o && t.tokens[n].type === "paragraph_open" && (t.tokens[n + 2].hidden = !0, t.tokens[n].hidden = !0, n += 2) } var Ks = function (e, n, r, o) { var s, i, c, a, l, u, d, f, h, m, x, C, v, b, E, q, T, k, B, U, G, N, P, ce, re, _, O, L, g = !1, y = !0; if (e.sCount[n] - e.blkIndent >= 4 || e.listIndent >= 0 && e.sCount[n] - e.listIndent >= 4 && e.sCount[n] < e.blkIndent) return !1; if (o && e.parentType === "paragraph" && e.sCount[n] >= e.blkIndent && (g = !0), (P = Vn(e, n)) >= 0) { if (d = !0, re = e.bMarks[n] + e.tShift[n], v = Number(e.src.slice(re, P - 1)), g && v !== 1) return !1 } else if ((P = Un(e, n)) >= 0) d = !1; else return !1; if (g && e.skipSpaces(P) >= e.eMarks[n]) return !1; if (C = e.src.charCodeAt(P - 1), o) return !0; for (x = e.tokens.length, d ? (L = e.push("ordered_list_open", "ol", 1), v !== 1 && (L.attrs = [["start", v]])) : L = e.push("bullet_list_open", "ul", 1), L.map = m = [n, 0], L.markup = String.fromCharCode(C), E = n, ce = !1, O = e.md.block.ruler.getRules("list"), k = e.parentType, e.parentType = "list"; E < r;) { for (N = P, b = e.eMarks[E], u = q = e.sCount[E] + P - (e.bMarks[n] + e.tShift[n]); N < b;) { if (s = e.src.charCodeAt(N), s === 9) q += 4 - (q + e.bsCount[E]) % 4; else if (s === 32) q++; else break; N++ } if (i = N, i >= b ? l = 1 : l = q - u, l > 4 && (l = 1), a = u + l, L = e.push("list_item_open", "li", 1), L.markup = String.fromCharCode(C), L.map = f = [n, 0], d && (L.info = e.src.slice(re, P - 1)), G = e.tight, U = e.tShift[n], B = e.sCount[n], T = e.listIndent, e.listIndent = e.blkIndent, e.blkIndent = a, e.tight = !0, e.tShift[n] = i - e.bMarks[n], e.sCount[n] = q, i >= b && e.isEmpty(n + 1) ? e.line = Math.min(e.line + 2, r) : e.md.block.tokenize(e, n, r, !0), (!e.tight || ce) && (y = !1), ce = e.line - n > 1 && e.isEmpty(e.line - 1), e.blkIndent = e.listIndent, e.listIndent = T, e.tShift[n] = U, e.sCount[n] = B, e.tight = G, L = e.push("list_item_close", "li", -1), L.markup = String.fromCharCode(C), E = n = e.line, f[1] = E, i = e.bMarks[n], E >= r || e.sCount[E] < e.blkIndent || e.sCount[n] - e.blkIndent >= 4) break; for (_ = !1, c = 0, h = O.length; c < h; c++)if (O[c](e, E, r, !0)) { _ = !0; break } if (_) break; if (d) { if (P = Vn(e, E), P < 0) break; re = e.bMarks[E] + e.tShift[E] } else if (P = Un(e, E), P < 0) break; if (C !== e.src.charCodeAt(P - 1)) break } return d ? L = e.push("ordered_list_close", "ol", -1) : L = e.push("bullet_list_close", "ul", -1), L.markup = String.fromCharCode(C), m[1] = E, e.line = E, e.parentType = k, y && Ws(e, x), !0 }, Js = I.normalizeReference, $e = I.isSpace, Ys = function (e, n, r, o) { var s, i, c, a, l, u, d, f, h, m, x, C, v, b, E, q, T = 0, k = e.bMarks[n] + e.tShift[n], B = e.eMarks[n], U = n + 1; if (e.sCount[n] - e.blkIndent >= 4 || e.src.charCodeAt(k) !== 91) return !1; for (; ++k < B;)if (e.src.charCodeAt(k) === 93 && e.src.charCodeAt(k - 1) !== 92) { if (k + 1 === B || e.src.charCodeAt(k + 1) !== 58) return !1; break } for (a = e.lineMax, E = e.md.block.ruler.getRules("reference"), m = e.parentType, e.parentType = "reference"; U < a && !e.isEmpty(U); U++)if (!(e.sCount[U] - e.blkIndent > 3) && !(e.sCount[U] < 0)) { for (b = !1, u = 0, d = E.length; u < d; u++)if (E[u](e, U, a, !0)) { b = !0; break } if (b) break } for (v = e.getLines(n, U, e.blkIndent, !1).trim(), B = v.length, k = 1; k < B; k++) { if (s = v.charCodeAt(k), s === 91) return !1; if (s === 93) { h = k; break } else s === 10 ? T++ : s === 92 && (k++, k < B && v.charCodeAt(k) === 10 && T++) } if (h < 0 || v.charCodeAt(h + 1) !== 58) return !1; for (k = h + 2; k < B; k++)if (s = v.charCodeAt(k), s === 10) T++; else if (!$e(s)) break; if (x = e.md.helpers.parseLinkDestination(v, k, B), !x.ok || (l = e.md.normalizeLink(x.str), !e.md.validateLink(l))) return !1; for (k = x.pos, T += x.lines, i = k, c = T, C = k; k < B; k++)if (s = v.charCodeAt(k), s === 10) T++; else if (!$e(s)) break; for (x = e.md.helpers.parseLinkTitle(v, k, B), k < B && C !== k && x.ok ? (q = x.str, k = x.pos, T += x.lines) : (q = "", k = i, T = c); k < B && (s = v.charCodeAt(k), !!$e(s));)k++; if (k < B && v.charCodeAt(k) !== 10 && q) for (q = "", k = i, T = c; k < B && (s = v.charCodeAt(k), !!$e(s));)k++; return k < B && v.charCodeAt(k) !== 10 || (f = Js(v.slice(1, h)), !f) ? !1 : (o || (typeof e.env.references > "u" && (e.env.references = {}), typeof e.env.references[f] > "u" && (e.env.references[f] = { title: q, href: l }), e.parentType = m, e.line = n + T + 1), !0) }, Xs = ["address", "article", "aside", "base", "basefont", "blockquote", "body", "caption", "center", "col", "colgroup", "dd", "details", "dialog", "dir", "div", "dl", "dt", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hr", "html", "iframe", "legend", "li", "link", "main", "menu", "menuitem", "nav", "noframes", "ol", "optgroup", "option", "p", "param", "section", "source", "summary", "table", "tbody", "td", "tfoot", "th", "thead", "title", "tr", "track", "ul"], Ge = {}, Qs = "[a-zA-Z_:][a-zA-Z0-9:._-]*", ec = "[^\"'=<>`\\x00-\\x20]+", tc = "'[^']*'", nc = '"[^"]*"', rc = "(?:" + ec + "|" + tc + "|" + nc + ")", oc = "(?:\\s+" + Qs + "(?:\\s*=\\s*" + rc + ")?)", $n = "<[A-Za-z][A-Za-z0-9\\-]*" + oc + "*\\s*\\/?>", Gn = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>", sc = "<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->", cc = "<[?][\\s\\S]*?[?]>", ic = "<![A-Z]+\\s+[^>]*>", ac = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>", lc = new RegExp("^(?:" + $n + "|" + Gn + "|" + sc + "|" + cc + "|" + ic + "|" + ac + ")"), uc = new RegExp("^(?:" + $n + "|" + Gn + ")"); Ge.HTML_TAG_RE = lc, Ge.HTML_OPEN_CLOSE_TAG_RE = uc; var pc = Xs, fc = Ge.HTML_OPEN_CLOSE_TAG_RE, ve = [[/^<(script|pre|style|textarea)(?=(\s|>|$))/i, /<\/(script|pre|style|textarea)>/i, !0], [/^<!--/, /-->/, !0], [/^<\?/, /\?>/, !0], [/^<![A-Z]/, />/, !0], [/^<!\[CDATA\[/, /\]\]>/, !0], [new RegExp("^</?(" + pc.join("|") + ")(?=(\\s|/?>|$))", "i"), /^$/, !0], [new RegExp(fc.source + "\\s*$"), /^$/, !1]], hc = function (e, n, r, o) { var s, i, c, a, l = e.bMarks[n] + e.tShift[n], u = e.eMarks[n]; if (e.sCount[n] - e.blkIndent >= 4 || !e.md.options.html || e.src.charCodeAt(l) !== 60) return !1; for (a = e.src.slice(l, u), s = 0; s < ve.length && !ve[s][0].test(a); s++); if (s === ve.length) return !1; if (o) return ve[s][2]; if (i = n + 1, !ve[s][1].test(a)) { for (; i < r && !(e.sCount[i] < e.blkIndent); i++)if (l = e.bMarks[i] + e.tShift[i], u = e.eMarks[i], a = e.src.slice(l, u), ve[s][1].test(a)) { a.length !== 0 && i++; break } } return e.line = i, c = e.push("html_block", "", 0), c.map = [n, i], c.content = e.getLines(n, i, e.blkIndent, !0), !0 }, Hn = I.isSpace, dc = function (e, n, r, o) { var s, i, c, a, l = e.bMarks[n] + e.tShift[n], u = e.eMarks[n]; if (e.sCount[n] - e.blkIndent >= 4 || (s = e.src.charCodeAt(l), s !== 35 || l >= u)) return !1; for (i = 1, s = e.src.charCodeAt(++l); s === 35 && l < u && i <= 6;)i++, s = e.src.charCodeAt(++l); return i > 6 || l < u && !Hn(s) ? !1 : (o || (u = e.skipSpacesBack(u, l), c = e.skipCharsBack(u, 35, l), c > l && Hn(e.src.charCodeAt(c - 1)) && (u = c), e.line = n + 1, a = e.push("heading_open", "h" + String(i), 1), a.markup = "########".slice(0, i), a.map = [n, e.line], a = e.push("inline", "", 0), a.content = e.src.slice(l, u).trim(), a.map = [n, e.line], a.children = [], a = e.push("heading_close", "h" + String(i), -1), a.markup = "########".slice(0, i)), !0) }, gc = function (e, n, r) { var o, s, i, c, a, l, u, d, f, h = n + 1, m, x = e.md.block.ruler.getRules("paragraph"); if (e.sCount[n] - e.blkIndent >= 4) return !1; for (m = e.parentType, e.parentType = "paragraph"; h < r && !e.isEmpty(h); h++)if (!(e.sCount[h] - e.blkIndent > 3)) { if (e.sCount[h] >= e.blkIndent && (l = e.bMarks[h] + e.tShift[h], u = e.eMarks[h], l < u && (f = e.src.charCodeAt(l), (f === 45 || f === 61) && (l = e.skipChars(l, f), l = e.skipSpaces(l), l >= u)))) { d = f === 61 ? 1 : 2; break } if (!(e.sCount[h] < 0)) { for (s = !1, i = 0, c = x.length; i < c; i++)if (x[i](e, h, r, !0)) { s = !0; break } if (s) break } } return d ? (o = e.getLines(n, h, e.blkIndent, !1).trim(), e.line = h + 1, a = e.push("heading_open", "h" + String(d), 1), a.markup = String.fromCharCode(f), a.map = [n, e.line], a = e.push("inline", "", 0), a.content = o, a.map = [n, e.line - 1], a.children = [], a = e.push("heading_close", "h" + String(d), -1), a.markup = String.fromCharCode(f), e.parentType = m, !0) : !1 }, mc = function (e, n) { var r, o, s, i, c, a, l = n + 1, u = e.md.block.ruler.getRules("paragraph"), d = e.lineMax; for (a = e.parentType, e.parentType = "paragraph"; l < d && !e.isEmpty(l); l++)if (!(e.sCount[l] - e.blkIndent > 3) && !(e.sCount[l] < 0)) { for (o = !1, s = 0, i = u.length; s < i; s++)if (u[s](e, l, d, !0)) { o = !0; break } if (o) break } return r = e.getLines(n, l, e.blkIndent, !1).trim(), e.line = l, c = e.push("paragraph_open", "p", 1), c.map = [n, e.line], c = e.push("inline", "", 0), c.content = r, c.map = [n, e.line], c.children = [], c = e.push("paragraph_close", "p", -1), e.parentType = a, !0 }, jn = gt, He = I.isSpace; function ee(t, e, n, r) { var o, s, i, c, a, l, u, d; for (this.src = t, this.md = e, this.env = n, this.tokens = r, this.bMarks = [], this.eMarks = [], this.tShift = [], this.sCount = [], this.bsCount = [], this.blkIndent = 0, this.line = 0, this.lineMax = 0, this.tight = !1, this.ddIndent = -1, this.listIndent = -1, this.parentType = "root", this.level = 0, this.result = "", s = this.src, d = !1, i = c = l = u = 0, a = s.length; c < a; c++) { if (o = s.charCodeAt(c), !d) if (He(o)) { l++, o === 9 ? u += 4 - u % 4 : u++; continue } else d = !0; (o === 10 || c === a - 1) && (o !== 10 && c++, this.bMarks.push(i), this.eMarks.push(c), this.tShift.push(l), this.sCount.push(u), this.bsCount.push(0), d = !1, l = 0, u = 0, i = c + 1) } this.bMarks.push(s.length), this.eMarks.push(s.length), this.tShift.push(0), this.sCount.push(0), this.bsCount.push(0), this.lineMax = this.bMarks.length - 1 } ee.prototype.push = function (t, e, n) { var r = new jn(t, e, n); return r.block = !0, n < 0 && this.level--, r.level = this.level, n > 0 && this.level++, this.tokens.push(r), r }, ee.prototype.isEmpty = function (e) { return this.bMarks[e] + this.tShift[e] >= this.eMarks[e] }, ee.prototype.skipEmptyLines = function (e) { for (var n = this.lineMax; e < n && !(this.bMarks[e] + this.tShift[e] < this.eMarks[e]); e++); return e }, ee.prototype.skipSpaces = function (e) { for (var n, r = this.src.length; e < r && (n = this.src.charCodeAt(e), !!He(n)); e++); return e }, ee.prototype.skipSpacesBack = function (e, n) { if (e <= n) return e; for (; e > n;)if (!He(this.src.charCodeAt(--e))) return e + 1; return e }, ee.prototype.skipChars = function (e, n) { for (var r = this.src.length; e < r && this.src.charCodeAt(e) === n; e++); return e }, ee.prototype.skipCharsBack = function (e, n, r) { if (e <= r) return e; for (; e > r;)if (n !== this.src.charCodeAt(--e)) return e + 1; return e }, ee.prototype.getLines = function (e, n, r, o) { var s, i, c, a, l, u, d, f = e; if (e >= n) return ""; for (u = new Array(n - e), s = 0; f < n; f++, s++) { for (i = 0, d = a = this.bMarks[f], f + 1 < n || o ? l = this.eMarks[f] + 1 : l = this.eMarks[f]; a < l && i < r;) { if (c = this.src.charCodeAt(a), He(c)) c === 9 ? i += 4 - (i + this.bsCount[f]) % 4 : i++; else if (a - d < this.tShift[f]) i++; else break; a++ } i > r ? u[s] = new Array(i - r + 1).join(" ") + this.src.slice(a, l) : u[s] = this.src.slice(a, l) } return u.join("") }, ee.prototype.Token = jn; var bc = ee, _c = dt, je = [["table", Vs, ["paragraph", "reference"]], ["code", $s], ["fence", Gs, ["paragraph", "reference", "blockquote", "list"]], ["blockquote", Hs, ["paragraph", "reference", "blockquote", "list"]], ["hr", Zs, ["paragraph", "reference", "blockquote", "list"]], ["list", Ks, ["paragraph", "reference", "blockquote"]], ["reference", Ys], ["html_block", hc, ["paragraph", "reference", "blockquote"]], ["heading", dc, ["paragraph", "reference", "blockquote"]], ["lheading", gc], ["paragraph", mc]]; function Ze() { this.ruler = new _c; for (var t = 0; t < je.length; t++)this.ruler.push(je[t][0], je[t][1], { alt: (je[t][2] || []).slice() }) } Ze.prototype.tokenize = function (t, e, n) { for (var r, o, s = this.ruler.getRules(""), i = s.length, c = e, a = !1, l = t.md.options.maxNesting; c < n && (t.line = c = t.skipEmptyLines(c), !(c >= n || t.sCount[c] < t.blkIndent));) { if (t.level >= l) { t.line = n; break } for (o = 0; o < i && (r = s[o](t, c, n, !1), !r); o++); t.tight = !a, t.isEmpty(t.line - 1) && (a = !0), c = t.line, c < n && t.isEmpty(c) && (a = !0, c++, t.line = c) } }, Ze.prototype.parse = function (t, e, n, r) { var o; t && (o = new this.State(t, e, n, r), this.tokenize(o, o.line, o.lineMax)) }, Ze.prototype.State = bc; var kc = Ze; function xc(t) { switch (t) { case 10: case 33: case 35: case 36: case 37: case 38: case 42: case 43: case 45: case 58: case 60: case 61: case 62: case 64: case 91: case 92: case 93: case 94: case 95: case 96: case 123: case 125: case 126: return !0; default: return !1 } } for (var wc = function (e, n) { for (var r = e.pos; r < e.posMax && !xc(e.src.charCodeAt(r));)r++; return r === e.pos ? !1 : (n || (e.pending += e.src.slice(e.pos, r)), e.pos = r, !0) }, yc = I.isSpace, vc = function (e, n) { var r, o, s, i = e.pos; if (e.src.charCodeAt(i) !== 10) return !1; if (r = e.pending.length - 1, o = e.posMax, !n) if (r >= 0 && e.pending.charCodeAt(r) === 32) if (r >= 1 && e.pending.charCodeAt(r - 1) === 32) { for (s = r - 1; s >= 1 && e.pending.charCodeAt(s - 1) === 32;)s--; e.pending = e.pending.slice(0, s), e.push("hardbreak", "br", 0) } else e.pending = e.pending.slice(0, -1), e.push("softbreak", "br", 0); else e.push("softbreak", "br", 0); for (i++; i < o && yc(e.src.charCodeAt(i));)i++; return e.pos = i, !0 }, Ec = I.isSpace, xt = [], Zn = 0; Zn < 256; Zn++)xt.push(0); "\\!\"#$%&'()*+,./:;<=>?@[]^_`{|}~-".split("").forEach(function (t) { xt[t.charCodeAt(0)] = 1 }); var Ac = function (e, n) { var r, o = e.pos, s = e.posMax; if (e.src.charCodeAt(o) !== 92) return !1; if (o++, o < s) { if (r = e.src.charCodeAt(o), r < 256 && xt[r] !== 0) return n || (e.pending += e.src[o]), e.pos += 2, !0; if (r === 10) { for (n || e.push("hardbreak", "br", 0), o++; o < s && (r = e.src.charCodeAt(o), !!Ec(r));)o++; return e.pos = o, !0 } } return n || (e.pending += "\\"), e.pos++, !0 }, Cc = function (e, n) { var r, o, s, i, c, a, l, u, d = e.pos, f = e.src.charCodeAt(d); if (f !== 96) return !1; for (r = d, d++, o = e.posMax; d < o && e.src.charCodeAt(d) === 96;)d++; if (s = e.src.slice(r, d), l = s.length, e.backticksScanned && (e.backticks[l] || 0) <= r) return n || (e.pending += s), e.pos += l, !0; for (c = a = d; (c = e.src.indexOf("`", a)) !== -1;) { for (a = c + 1; a < o && e.src.charCodeAt(a) === 96;)a++; if (u = a - c, u === l) return n || (i = e.push("code_inline", "code", 0), i.markup = s, i.content = e.src.slice(d, c).replace(/\n/g, " ").replace(/^ (.+) $/, "$1")), e.pos = a, !0; e.backticks[u] = c } return e.backticksScanned = !0, n || (e.pending += s), e.pos += l, !0 }, We = {}; We.tokenize = function (e, n) { var r, o, s, i, c, a = e.pos, l = e.src.charCodeAt(a); if (n || l !== 126 || (o = e.scanDelims(e.pos, !0), i = o.length, c = String.fromCharCode(l), i < 2)) return !1; for (i % 2 && (s = e.push("text", "", 0), s.content = c, i--), r = 0; r < i; r += 2)s = e.push("text", "", 0), s.content = c + c, e.delimiters.push({ marker: l, length: 0, token: e.tokens.length - 1, end: -1, open: o.can_open, close: o.can_close }); return e.pos += o.length, !0 }; function Wn(t, e) { var n, r, o, s, i, c = [], a = e.length; for (n = 0; n < a; n++)o = e[n], o.marker === 126 && o.end !== -1 && (s = e[o.end], i = t.tokens[o.token], i.type = "s_open", i.tag = "s", i.nesting = 1, i.markup = "~~", i.content = "", i = t.tokens[s.token], i.type = "s_close", i.tag = "s", i.nesting = -1, i.markup = "~~", i.content = "", t.tokens[s.token - 1].type === "text" && t.tokens[s.token - 1].content === "~" && c.push(s.token - 1)); for (; c.length;) { for (n = c.pop(), r = n + 1; r < t.tokens.length && t.tokens[r].type === "s_close";)r++; r--, n !== r && (i = t.tokens[r], t.tokens[r] = t.tokens[n], t.tokens[n] = i) } } We.postProcess = function (e) { var n, r = e.tokens_meta, o = e.tokens_meta.length; for (Wn(e, e.delimiters), n = 0; n < o; n++)r[n] && r[n].delimiters && Wn(e, r[n].delimiters) }; var Ke = {}; Ke.tokenize = function (e, n) { var r, o, s, i = e.pos, c = e.src.charCodeAt(i); if (n || c !== 95 && c !== 42) return !1; for (o = e.scanDelims(e.pos, c === 42), r = 0; r < o.length; r++)s = e.push("text", "", 0), s.content = String.fromCharCode(c), e.delimiters.push({ marker: c, length: o.length, token: e.tokens.length - 1, end: -1, open: o.can_open, close: o.can_close }); return e.pos += o.length, !0 }; function Kn(t, e) { var n, r, o, s, i, c, a = e.length; for (n = a - 1; n >= 0; n--)r = e[n], !(r.marker !== 95 && r.marker !== 42) && r.end !== -1 && (o = e[r.end], c = n > 0 && e[n - 1].end === r.end + 1 && e[n - 1].marker === r.marker && e[n - 1].token === r.token - 1 && e[r.end + 1].token === o.token + 1, i = String.fromCharCode(r.marker), s = t.tokens[r.token], s.type = c ? "strong_open" : "em_open", s.tag = c ? "strong" : "em", s.nesting = 1, s.markup = c ? i + i : i, s.content = "", s = t.tokens[o.token], s.type = c ? "strong_close" : "em_close", s.tag = c ? "strong" : "em", s.nesting = -1, s.markup = c ? i + i : i, s.content = "", c && (t.tokens[e[n - 1].token].content = "", t.tokens[e[r.end + 1].token].content = "", n--)) } Ke.postProcess = function (e) { var n, r = e.tokens_meta, o = e.tokens_meta.length; for (Kn(e, e.delimiters), n = 0; n < o; n++)r[n] && r[n].delimiters && Kn(e, r[n].delimiters) }; var qc = I.normalizeReference, wt = I.isSpace, Sc = function (e, n) { var r, o, s, i, c, a, l, u, d, f = "", h = "", m = e.pos, x = e.posMax, C = e.pos, v = !0; if (e.src.charCodeAt(e.pos) !== 91 || (c = e.pos + 1, i = e.md.helpers.parseLinkLabel(e, e.pos, !0), i < 0)) return !1; if (a = i + 1, a < x && e.src.charCodeAt(a) === 40) { for (v = !1, a++; a < x && (o = e.src.charCodeAt(a), !(!wt(o) && o !== 10)); a++); if (a >= x) return !1; if (C = a, l = e.md.helpers.parseLinkDestination(e.src, a, e.posMax), l.ok) { for (f = e.md.normalizeLink(l.str), e.md.validateLink(f) ? a = l.pos : f = "", C = a; a < x && (o = e.src.charCodeAt(a), !(!wt(o) && o !== 10)); a++); if (l = e.md.helpers.parseLinkTitle(e.src, a, e.posMax), a < x && C !== a && l.ok) for (h = l.str, a = l.pos; a < x && (o = e.src.charCodeAt(a), !(!wt(o) && o !== 10)); a++); } (a >= x || e.src.charCodeAt(a) !== 41) && (v = !0), a++ } if (v) { if (typeof e.env.references > "u") return !1; if (a < x && e.src.charCodeAt(a) === 91 ? (C = a + 1, a = e.md.helpers.parseLinkLabel(e, a), a >= 0 ? s = e.src.slice(C, a++) : a = i + 1) : a = i + 1, s || (s = e.src.slice(c, i)), u = e.env.references[qc(s)], !u) return e.pos = m, !1; f = u.href, h = u.title } return n || (e.pos = c, e.posMax = i, d = e.push("link_open", "a", 1), d.attrs = r = [["href", f]], h && r.push(["title", h]), e.md.inline.tokenize(e), d = e.push("link_close", "a", -1)), e.pos = a, e.posMax = x, !0 }, Dc = I.normalizeReference, yt = I.isSpace, Tc = function (e, n) { var r, o, s, i, c, a, l, u, d, f, h, m, x, C = "", v = e.pos, b = e.posMax; if (e.src.charCodeAt(e.pos) !== 33 || e.src.charCodeAt(e.pos + 1) !== 91 || (a = e.pos + 2, c = e.md.helpers.parseLinkLabel(e, e.pos + 1, !1), c < 0)) return !1; if (l = c + 1, l < b && e.src.charCodeAt(l) === 40) { for (l++; l < b && (o = e.src.charCodeAt(l), !(!yt(o) && o !== 10)); l++); if (l >= b) return !1; for (x = l, d = e.md.helpers.parseLinkDestination(e.src, l, e.posMax), d.ok && (C = e.md.normalizeLink(d.str), e.md.validateLink(C) ? l = d.pos : C = ""), x = l; l < b && (o = e.src.charCodeAt(l), !(!yt(o) && o !== 10)); l++); if (d = e.md.helpers.parseLinkTitle(e.src, l, e.posMax), l < b && x !== l && d.ok) for (f = d.str, l = d.pos; l < b && (o = e.src.charCodeAt(l), !(!yt(o) && o !== 10)); l++); else f = ""; if (l >= b || e.src.charCodeAt(l) !== 41) return e.pos = v, !1; l++ } else { if (typeof e.env.references > "u") return !1; if (l < b && e.src.charCodeAt(l) === 91 ? (x = l + 1, l = e.md.helpers.parseLinkLabel(e, l), l >= 0 ? i = e.src.slice(x, l++) : l = c + 1) : l = c + 1, i || (i = e.src.slice(a, c)), u = e.env.references[Dc(i)], !u) return e.pos = v, !1; C = u.href, f = u.title } return n || (s = e.src.slice(a, c), e.md.inline.parse(s, e.md, e.env, m = []), h = e.push("image", "img", 0), h.attrs = r = [["src", C], ["alt", ""]], h.children = m, h.content = s, f && r.push(["title", f])), e.pos = l, e.posMax = b, !0 }, Rc = /^([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$/, Nc = /^([a-zA-Z][a-zA-Z0-9+.\-]{1,31}):([^<>\x00-\x20]*)$/, Lc = function (e, n) { var r, o, s, i, c, a, l = e.pos; if (e.src.charCodeAt(l) !== 60) return !1; for (c = e.pos, a = e.posMax; ;) { if (++l >= a || (i = e.src.charCodeAt(l), i === 60)) return !1; if (i === 62) break } return r = e.src.slice(c + 1, l), Nc.test(r) ? (o = e.md.normalizeLink(r), e.md.validateLink(o) ? (n || (s = e.push("link_open", "a", 1), s.attrs = [["href", o]], s.markup = "autolink", s.info = "auto", s = e.push("text", "", 0), s.content = e.md.normalizeLinkText(r), s = e.push("link_close", "a", -1), s.markup = "autolink", s.info = "auto"), e.pos += r.length + 2, !0) : !1) : Rc.test(r) ? (o = e.md.normalizeLink("mailto:" + r), e.md.validateLink(o) ? (n || (s = e.push("link_open", "a", 1), s.attrs = [["href", o]], s.markup = "autolink", s.info = "auto", s = e.push("text", "", 0), s.content = e.md.normalizeLinkText(r), s = e.push("link_close", "a", -1), s.markup = "autolink", s.info = "auto"), e.pos += r.length + 2, !0) : !1) : !1 }, Bc = Ge.HTML_TAG_RE; function Mc(t) { var e = t | 32; return e >= 97 && e <= 122 } var Ic = function (e, n) { var r, o, s, i, c = e.pos; return !e.md.options.html || (s = e.posMax, e.src.charCodeAt(c) !== 60 || c + 2 >= s) || (r = e.src.charCodeAt(c + 1), r !== 33 && r !== 63 && r !== 47 && !Mc(r)) || (o = e.src.slice(c).match(Bc), !o) ? !1 : (n || (i = e.push("html_inline", "", 0), i.content = e.src.slice(c, c + o[0].length)), e.pos += o[0].length, !0) }, Jn = dn, Oc = I.has, Fc = I.isValidEntityCode, Yn = I.fromCodePoint, Pc = /^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i, zc = /^&([a-z][a-z0-9]{1,31});/i, Uc = function (e, n) { var r, o, s, i = e.pos, c = e.posMax; if (e.src.charCodeAt(i) !== 38) return !1; if (i + 1 < c) { if (r = e.src.charCodeAt(i + 1), r === 35) { if (s = e.src.slice(i).match(Pc), s) return n || (o = s[1][0].toLowerCase() === "x" ? parseInt(s[1].slice(1), 16) : parseInt(s[1], 10), e.pending += Fc(o) ? Yn(o) : Yn(65533)), e.pos += s[0].length, !0 } else if (s = e.src.slice(i).match(zc), s && Oc(Jn, s[1])) return n || (e.pending += Jn[s[1]]), e.pos += s[0].length, !0 } return n || (e.pending += "&"), e.pos++, !0 }; function Xn(t, e) { var n, r, o, s, i, c, a, l, u = {}, d = e.length; if (d) { var f = 0, h = -2, m = []; for (n = 0; n < d; n++)if (o = e[n], m.push(0), (e[f].marker !== o.marker || h !== o.token - 1) && (f = n), h = o.token, o.length = o.length || 0, !!o.close) { for (u.hasOwnProperty(o.marker) || (u[o.marker] = [-1, -1, -1, -1, -1, -1]), i = u[o.marker][(o.open ? 3 : 0) + o.length % 3], r = f - m[f] - 1, c = r; r > i; r -= m[r] + 1)if (s = e[r], s.marker === o.marker && s.open && s.end < 0 && (a = !1, (s.close || o.open) && (s.length + o.length) % 3 === 0 && (s.length % 3 !== 0 || o.length % 3 !== 0) && (a = !0), !a)) { l = r > 0 && !e[r - 1].open ? m[r - 1] + 1 : 0, m[n] = n - r + l, m[r] = l, o.open = !1, s.end = n, s.close = !1, c = -1, h = -2; break } c !== -1 && (u[o.marker][(o.open ? 3 : 0) + (o.length || 0) % 3] = c) } } } var Vc = function (e) { var n, r = e.tokens_meta, o = e.tokens_meta.length; for (Xn(e, e.delimiters), n = 0; n < o; n++)r[n] && r[n].delimiters && Xn(e, r[n].delimiters) }, $c = function (e) { var n, r, o = 0, s = e.tokens, i = e.tokens.length; for (n = r = 0; n < i; n++)s[n].nesting < 0 && o--, s[n].level = o, s[n].nesting > 0 && o++, s[n].type === "text" && n + 1 < i && s[n + 1].type === "text" ? s[n + 1].content = s[n].content + s[n + 1].content : (n !== r && (s[r] = s[n]), r++); n !== r && (s.length = r) }, vt = gt, Qn = I.isWhiteSpace, er = I.isPunctChar, tr = I.isMdAsciiPunct; function Se(t, e, n, r) { this.src = t, this.env = n, this.md = e, this.tokens = r, this.tokens_meta = Array(r.length), this.pos = 0, this.posMax = this.src.length, this.level = 0, this.pending = "", this.pendingLevel = 0, this.cache = {}, this.delimiters = [], this._prev_delimiters = [], this.backticks = {}, this.backticksScanned = !1 } Se.prototype.pushPending = function () { var t = new vt("text", "", 0); return t.content = this.pending, t.level = this.pendingLevel, this.tokens.push(t), this.pending = "", t }, Se.prototype.push = function (t, e, n) { this.pending && this.pushPending(); var r = new vt(t, e, n), o = null; return n < 0 && (this.level--, this.delimiters = this._prev_delimiters.pop()), r.level = this.level, n > 0 && (this.level++, this._prev_delimiters.push(this.delimiters), this.delimiters = [], o = { delimiters: this.delimiters }), this.pendingLevel = this.level, this.tokens.push(r), this.tokens_meta.push(o), r }, Se.prototype.scanDelims = function (t, e) { var n = t, r, o, s, i, c, a, l, u, d, f = !0, h = !0, m = this.posMax, x = this.src.charCodeAt(t); for (r = t > 0 ? this.src.charCodeAt(t - 1) : 32; n < m && this.src.charCodeAt(n) === x;)n++; return s = n - t, o = n < m ? this.src.charCodeAt(n) : 32, l = tr(r) || er(String.fromCharCode(r)), d = tr(o) || er(String.fromCharCode(o)), a = Qn(r), u = Qn(o), u ? f = !1 : d && (a || l || (f = !1)), a ? h = !1 : l && (u || d || (h = !1)), e ? (i = f, c = h) : (i = f && (!h || l), c = h && (!f || d)), { can_open: i, can_close: c, length: s } }, Se.prototype.Token = vt; var Gc = Se, nr = dt, Et = [["text", wc], ["newline", vc], ["escape", Ac], ["backticks", Cc], ["strikethrough", We.tokenize], ["emphasis", Ke.tokenize], ["link", Sc], ["image", Tc], ["autolink", Lc], ["html_inline", Ic], ["entity", Uc]], At = [["balance_pairs", Vc], ["strikethrough", We.postProcess], ["emphasis", Ke.postProcess], ["text_collapse", $c]]; function De() { var t; for (this.ruler = new nr, t = 0; t < Et.length; t++)this.ruler.push(Et[t][0], Et[t][1]); for (this.ruler2 = new nr, t = 0; t < At.length; t++)this.ruler2.push(At[t][0], At[t][1]) } De.prototype.skipToken = function (t) { var e, n, r = t.pos, o = this.ruler.getRules(""), s = o.length, i = t.md.options.maxNesting, c = t.cache; if (typeof c[r] < "u") { t.pos = c[r]; return } if (t.level < i) for (n = 0; n < s && (t.level++, e = o[n](t, !0), t.level--, !e); n++); else t.pos = t.posMax; e || t.pos++, c[r] = t.pos }, De.prototype.tokenize = function (t) { for (var e, n, r = this.ruler.getRules(""), o = r.length, s = t.posMax, i = t.md.options.maxNesting; t.pos < s;) { if (t.level < i) for (n = 0; n < o && (e = r[n](t, !1), !e); n++); if (e) { if (t.pos >= s) break; continue } t.pending += t.src[t.pos++] } t.pending && t.pushPending() }, De.prototype.parse = function (t, e, n, r) { var o, s, i, c = new this.State(t, e, n, r); for (this.tokenize(c), s = this.ruler2.getRules(""), i = s.length, o = 0; o < i; o++)s[o](c) }, De.prototype.State = Gc; var Hc = De, Ct, rr; function jc() { return rr || (rr = 1, Ct = function (t) { var e = {}; e.src_Any = vn().source, e.src_Cc = An().source, e.src_Z = Sn().source, e.src_P = lt.source, e.src_ZPCc = [e.src_Z, e.src_P, e.src_Cc].join("|"), e.src_ZCc = [e.src_Z, e.src_Cc].join("|"); var n = "[><ÔΩú]"; return e.src_pseudo_letter = "(?:(?!" + n + "|" + e.src_ZPCc + ")" + e.src_Any + ")", e.src_ip4 = "(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)", e.src_auth = "(?:(?:(?!" + e.src_ZCc + "|[@/\\[\\]()]).)+@)?", e.src_port = "(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?", e.src_host_terminator = "(?=$|" + n + "|" + e.src_ZPCc + ")(?!-|_|:\\d|\\.-|\\.(?!$|" + e.src_ZPCc + "))", e.src_path = "(?:[/?#](?:(?!" + e.src_ZCc + "|" + n + `|[()[\\]{}.,"'?!\\-;]).|\\[(?:(?!` + e.src_ZCc + "|\\]).)*\\]|\\((?:(?!" + e.src_ZCc + "|[)]).)*\\)|\\{(?:(?!" + e.src_ZCc + '|[}]).)*\\}|\\"(?:(?!' + e.src_ZCc + `|["]).)+\\"|\\'(?:(?!` + e.src_ZCc + "|[']).)+\\'|\\'(?=" + e.src_pseudo_letter + "|[-]).|\\.{2,}[a-zA-Z0-9%/&]|\\.(?!" + e.src_ZCc + "|[.]).|" + (t && t["---"] ? "\\-(?!--(?:[^-]|$))(?:-*)|" : "\\-+|") + ",(?!" + e.src_ZCc + ").|;(?!" + e.src_ZCc + ").|\\!+(?!" + e.src_ZCc + "|[!]).|\\?(?!" + e.src_ZCc + "|[?]).)+|\\/)?", e.src_email_name = '[\\-;:&=\\+\\$,\\.a-zA-Z0-9_][\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]*', e.src_xn = "xn--[a-z0-9\\-]{1,59}", e.src_domain_root = "(?:" + e.src_xn + "|" + e.src_pseudo_letter + "{1,63})", e.src_domain = "(?:" + e.src_xn + "|(?:" + e.src_pseudo_letter + ")|(?:" + e.src_pseudo_letter + "(?:-|" + e.src_pseudo_letter + "){0,61}" + e.src_pseudo_letter + "))", e.src_host = "(?:(?:(?:(?:" + e.src_domain + ")\\.)*" + e.src_domain + "))", e.tpl_host_fuzzy = "(?:" + e.src_ip4 + "|(?:(?:(?:" + e.src_domain + ")\\.)+(?:%TLDS%)))", e.tpl_host_no_ip_fuzzy = "(?:(?:(?:" + e.src_domain + ")\\.)+(?:%TLDS%))", e.src_host_strict = e.src_host + e.src_host_terminator, e.tpl_host_fuzzy_strict = e.tpl_host_fuzzy + e.src_host_terminator, e.src_host_port_strict = e.src_host + e.src_port + e.src_host_terminator, e.tpl_host_port_fuzzy_strict = e.tpl_host_fuzzy + e.src_port + e.src_host_terminator, e.tpl_host_port_no_ip_fuzzy_strict = e.tpl_host_no_ip_fuzzy + e.src_port + e.src_host_terminator, e.tpl_host_fuzzy_test = "localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:" + e.src_ZPCc + "|>|$))", e.tpl_email_fuzzy = "(^|" + n + '|"|\\(|' + e.src_ZCc + ")(" + e.src_email_name + "@" + e.tpl_host_fuzzy_strict + ")", e.tpl_link_fuzzy = "(^|(?![.:/\\-_@])(?:[$+<=>^`|ÔΩú]|" + e.src_ZPCc + "))((?![$+<=>^`|ÔΩú])" + e.tpl_host_port_fuzzy_strict + e.src_path + ")", e.tpl_link_no_ip_fuzzy = "(^|(?![.:/\\-_@])(?:[$+<=>^`|ÔΩú]|" + e.src_ZPCc + "))((?![$+<=>^`|ÔΩú])" + e.tpl_host_port_no_ip_fuzzy_strict + e.src_path + ")", e }), Ct } function qt(t) { var e = Array.prototype.slice.call(arguments, 1); return e.forEach(function (n) { n && Object.keys(n).forEach(function (r) { t[r] = n[r] }) }), t } function Je(t) { return Object.prototype.toString.call(t) } function Zc(t) { return Je(t) === "[object String]" } function Wc(t) { return Je(t) === "[object Object]" } function Kc(t) { return Je(t) === "[object RegExp]" } function or(t) { return Je(t) === "[object Function]" } function Jc(t) { return t.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&") } var sr = { fuzzyLink: !0, fuzzyEmail: !0, fuzzyIP: !1 }; function Yc(t) { return Object.keys(t || {}).reduce(function (e, n) { return e || sr.hasOwnProperty(n) }, !1) } var Xc = { "http:": { validate: function (t, e, n) { var r = t.slice(e); return n.re.http || (n.re.http = new RegExp("^\\/\\/" + n.re.src_auth + n.re.src_host_port_strict + n.re.src_path, "i")), n.re.http.test(r) ? r.match(n.re.http)[0].length : 0 } }, "https:": "http:", "ftp:": "http:", "//": { validate: function (t, e, n) { var r = t.slice(e); return n.re.no_http || (n.re.no_http = new RegExp("^" + n.re.src_auth + "(?:localhost|(?:(?:" + n.re.src_domain + ")\\.)+" + n.re.src_domain_root + ")" + n.re.src_port + n.re.src_host_terminator + n.re.src_path, "i")), n.re.no_http.test(r) ? e >= 3 && t[e - 3] === ":" || e >= 3 && t[e - 3] === "/" ? 0 : r.match(n.re.no_http)[0].length : 0 } }, "mailto:": { validate: function (t, e, n) { var r = t.slice(e); return n.re.mailto || (n.re.mailto = new RegExp("^" + n.re.src_email_name + "@" + n.re.src_host_strict, "i")), n.re.mailto.test(r) ? r.match(n.re.mailto)[0].length : 0 } } }, Qc = "a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]", ei = "biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|—Ä—Ñ".split("|"); function ti(t) { t.__index__ = -1, t.__text_cache__ = "" } function ni(t) { return function (e, n) { var r = e.slice(n); return t.test(r) ? r.match(t)[0].length : 0 } } function cr() { return function (t, e) { e.normalize(t) } } function Ye(t) { var e = t.re = jc()(t.__opts__), n = t.__tlds__.slice(); t.onCompile(), t.__tlds_replaced__ || n.push(Qc), n.push(e.src_xn), e.src_tlds = n.join("|"); function r(c) { return c.replace("%TLDS%", e.src_tlds) } e.email_fuzzy = RegExp(r(e.tpl_email_fuzzy), "i"), e.link_fuzzy = RegExp(r(e.tpl_link_fuzzy), "i"), e.link_no_ip_fuzzy = RegExp(r(e.tpl_link_no_ip_fuzzy), "i"), e.host_fuzzy_test = RegExp(r(e.tpl_host_fuzzy_test), "i"); var o = []; t.__compiled__ = {}; function s(c, a) { throw new Error('(LinkifyIt) Invalid schema "' + c + '": ' + a) } Object.keys(t.__schemas__).forEach(function (c) { var a = t.__schemas__[c]; if (a !== null) { var l = { validate: null, link: null }; if (t.__compiled__[c] = l, Wc(a)) { Kc(a.validate) ? l.validate = ni(a.validate) : or(a.validate) ? l.validate = a.validate : s(c, a), or(a.normalize) ? l.normalize = a.normalize : a.normalize ? s(c, a) : l.normalize = cr(); return } if (Zc(a)) { o.push(c); return } s(c, a) } }), o.forEach(function (c) { t.__compiled__[t.__schemas__[c]] && (t.__compiled__[c].validate = t.__compiled__[t.__schemas__[c]].validate, t.__compiled__[c].normalize = t.__compiled__[t.__schemas__[c]].normalize) }), t.__compiled__[""] = { validate: null, normalize: cr() }; var i = Object.keys(t.__compiled__).filter(function (c) { return c.length > 0 && t.__compiled__[c] }).map(Jc).join("|"); t.re.schema_test = RegExp("(^|(?!_)(?:[><ÔΩú]|" + e.src_ZPCc + "))(" + i + ")", "i"), t.re.schema_search = RegExp("(^|(?!_)(?:[><ÔΩú]|" + e.src_ZPCc + "))(" + i + ")", "ig"), t.re.pretest = RegExp("(" + t.re.schema_test.source + ")|(" + t.re.host_fuzzy_test.source + ")|@", "i"), ti(t) } function ri(t, e) { var n = t.__index__, r = t.__last_index__, o = t.__text_cache__.slice(n, r); this.schema = t.__schema__.toLowerCase(), this.index = n + e, this.lastIndex = r + e, this.raw = o, this.text = o, this.url = o } function ir(t, e) { var n = new ri(t, e); return t.__compiled__[n.schema].normalize(n, t), n } function K(t, e) { if (!(this instanceof K)) return new K(t, e); e || Yc(t) && (e = t, t = {}), this.__opts__ = qt({}, sr, e), this.__index__ = -1, this.__last_index__ = -1, this.__schema__ = "", this.__text_cache__ = "", this.__schemas__ = qt({}, Xc, t), this.__compiled__ = {}, this.__tlds__ = ei, this.__tlds_replaced__ = !1, this.re = {}, Ye(this) } K.prototype.add = function (e, n) { return this.__schemas__[e] = n, Ye(this), this }, K.prototype.set = function (e) { return this.__opts__ = qt(this.__opts__, e), this }, K.prototype.test = function (e) { if (this.__text_cache__ = e, this.__index__ = -1, !e.length) return !1; var n, r, o, s, i, c, a, l, u; if (this.re.schema_test.test(e)) { for (a = this.re.schema_search, a.lastIndex = 0; (n = a.exec(e)) !== null;)if (s = this.testSchemaAt(e, n[2], a.lastIndex), s) { this.__schema__ = n[2], this.__index__ = n.index + n[1].length, this.__last_index__ = n.index + n[0].length + s; break } } return this.__opts__.fuzzyLink && this.__compiled__["http:"] && (l = e.search(this.re.host_fuzzy_test), l >= 0 && (this.__index__ < 0 || l < this.__index__) && (r = e.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null && (i = r.index + r[1].length, (this.__index__ < 0 || i < this.__index__) && (this.__schema__ = "", this.__index__ = i, this.__last_index__ = r.index + r[0].length))), this.__opts__.fuzzyEmail && this.__compiled__["mailto:"] && (u = e.indexOf("@"), u >= 0 && (o = e.match(this.re.email_fuzzy)) !== null && (i = o.index + o[1].length, c = o.index + o[0].length, (this.__index__ < 0 || i < this.__index__ || i === this.__index__ && c > this.__last_index__) && (this.__schema__ = "mailto:", this.__index__ = i, this.__last_index__ = c))), this.__index__ >= 0 }, K.prototype.pretest = function (e) { return this.re.pretest.test(e) }, K.prototype.testSchemaAt = function (e, n, r) { return this.__compiled__[n.toLowerCase()] ? this.__compiled__[n.toLowerCase()].validate(e, r, this) : 0 }, K.prototype.match = function (e) { var n = 0, r = []; this.__index__ >= 0 && this.__text_cache__ === e && (r.push(ir(this, n)), n = this.__last_index__); for (var o = n ? e.slice(n) : e; this.test(o);)r.push(ir(this, n)), o = o.slice(this.__last_index__), n += this.__last_index__; return r.length ? r : null }, K.prototype.tlds = function (e, n) { return e = Array.isArray(e) ? e : [e], n ? (this.__tlds__ = this.__tlds__.concat(e).sort().filter(function (r, o, s) { return r !== s[o - 1] }).reverse(), Ye(this), this) : (this.__tlds__ = e.slice(), this.__tlds_replaced__ = !0, Ye(this), this) }, K.prototype.normalize = function (e) { e.schema || (e.url = "http://" + e.url), e.schema === "mailto:" && !/^mailto:/i.test(e.url) && (e.url = "mailto:" + e.url) }, K.prototype.onCompile = function () { }; var oi = K; const Ee = 2147483647, te = 36, St = 1, Te = 26, si = 38, ci = 700, ar = 72, lr = 128, ur = "-", ii = /^xn--/, ai = /[^\0-\x7F]/, li = /[\x2E\u3002\uFF0E\uFF61]/g, ui = { overflow: "Overflow: input needs wider integers to process", "not-basic": "Illegal input >= 0x80 (not a basic code point)", "invalid-input": "Invalid input" }, Dt = te - St, ne = Math.floor, Tt = String.fromCharCode; function le(t) { throw new RangeError(ui[t]) } function pi(t, e) { const n = []; let r = t.length; for (; r--;)n[r] = e(t[r]); return n } function pr(t, e) { const n = t.split("@"); let r = ""; n.length > 1 && (r = n[0] + "@", t = n[1]), t = t.replace(li, "."); const o = t.split("."), s = pi(o, e).join("."); return r + s } function Rt(t) { const e = []; let n = 0; const r = t.length; for (; n < r;) { const o = t.charCodeAt(n++); if (o >= 55296 && o <= 56319 && n < r) { const s = t.charCodeAt(n++); (s & 64512) == 56320 ? e.push(((o & 1023) << 10) + (s & 1023) + 65536) : (e.push(o), n--) } else e.push(o) } return e } const fr = t => String.fromCodePoint(...t), fi = function (t) { return t >= 48 && t < 58 ? 26 + (t - 48) : t >= 65 && t < 91 ? t - 65 : t >= 97 && t < 123 ? t - 97 : te }, hr = function (t, e) { return t + 22 + 75 * (t < 26) - ((e != 0) << 5) }, dr = function (t, e, n) { let r = 0; for (t = n ? ne(t / ci) : t >> 1, t += ne(t / e); t > Dt * Te >> 1; r += te)t = ne(t / Dt); return ne(r + (Dt + 1) * t / (t + si)) }, Nt = function (t) { const e = [], n = t.length; let r = 0, o = lr, s = ar, i = t.lastIndexOf(ur); i < 0 && (i = 0); for (let c = 0; c < i; ++c)t.charCodeAt(c) >= 128 && le("not-basic"), e.push(t.charCodeAt(c)); for (let c = i > 0 ? i + 1 : 0; c < n;) { const a = r; for (let u = 1, d = te; ; d += te) { c >= n && le("invalid-input"); const f = fi(t.charCodeAt(c++)); f >= te && le("invalid-input"), f > ne((Ee - r) / u) && le("overflow"), r += f * u; const h = d <= s ? St : d >= s + Te ? Te : d - s; if (f < h) break; const m = te - h; u > ne(Ee / m) && le("overflow"), u *= m } const l = e.length + 1; s = dr(r - a, l, a == 0), ne(r / l) > Ee - o && le("overflow"), o += ne(r / l), r %= l, e.splice(r++, 0, o) } return String.fromCodePoint(...e) }, Lt = function (t) { const e = []; t = Rt(t); const n = t.length; let r = lr, o = 0, s = ar; for (const a of t) a < 128 && e.push(Tt(a)); const i = e.length; let c = i; for (i && e.push(ur); c < n;) { let a = Ee; for (const u of t) u >= r && u < a && (a = u); const l = c + 1; a - r > ne((Ee - o) / l) && le("overflow"), o += (a - r) * l, r = a; for (const u of t) if (u < r && ++o > Ee && le("overflow"), u === r) { let d = o; for (let f = te; ; f += te) { const h = f <= s ? St : f >= s + Te ? Te : f - s; if (d < h) break; const m = d - h, x = te - h; e.push(Tt(hr(h + m % x, 0))), d = ne(m / x) } e.push(Tt(hr(d, 0))), s = dr(o, l, c === i), o = 0, ++c } ++o, ++r } return e.join("") }, gr = function (t) { return pr(t, function (e) { return ii.test(e) ? Nt(e.slice(4).toLowerCase()) : e }) }, mr = function (t) { return pr(t, function (e) { return ai.test(e) ? "xn--" + Lt(e) : e }) }, hi = Sr(Object.freeze(Object.defineProperty({ __proto__: null, decode: Nt, default: { version: "2.3.1", ucs2: { decode: Rt, encode: fr }, decode: Nt, encode: Lt, toASCII: mr, toUnicode: gr }, encode: Lt, toASCII: mr, toUnicode: gr, ucs2decode: Rt, ucs2encode: fr }, Symbol.toStringTag, { value: "Module" }))); var di = { options: { html: !1, xhtmlOut: !1, breaks: !1, langPrefix: "language-", linkify: !1, typographer: !1, quotes: "‚Äú‚Äù‚Äò‚Äô", highlight: null, maxNesting: 100 }, components: { core: {}, block: {}, inline: {} } }, gi = { options: { html: !1, xhtmlOut: !1, breaks: !1, langPrefix: "language-", linkify: !1, typographer: !1, quotes: "‚Äú‚Äù‚Äò‚Äô", highlight: null, maxNesting: 20 }, components: { core: { rules: ["normalize", "block", "inline"] }, block: { rules: ["paragraph"] }, inline: { rules: ["text"], rules2: ["balance_pairs", "text_collapse"] } } }, mi = { options: { html: !0, xhtmlOut: !0, breaks: !1, langPrefix: "language-", linkify: !1, typographer: !1, quotes: "‚Äú‚Äù‚Äò‚Äô", highlight: null, maxNesting: 20 }, components: { core: { rules: ["normalize", "block", "inline"] }, block: { rules: ["blockquote", "code", "fence", "heading", "hr", "html_block", "lheading", "list", "reference", "paragraph"] }, inline: { rules: ["autolink", "backticks", "emphasis", "entity", "escape", "html_inline", "image", "link", "newline", "text"], rules2: ["balance_pairs", "emphasis", "text_collapse"] } } }, Re = I, bi = Ue, _i = _s, ki = Us, xi = kc, wi = Hc, yi = oi, me = xe, br = hi, vi = { default: di, zero: gi, commonmark: mi }, Ei = /^(vbscript|javascript|file|data):/, Ai = /^data:image\/(gif|png|jpeg|webp);/; function Ci(t) { var e = t.trim().toLowerCase(); return Ei.test(e) ? !!Ai.test(e) : !0 } var _r = ["http:", "https:", "mailto:"]; function qi(t) { var e = me.parse(t, !0); if (e.hostname && (!e.protocol || _r.indexOf(e.protocol) >= 0)) try { e.hostname = br.toASCII(e.hostname) } catch { } return me.encode(me.format(e)) } function Si(t) { var e = me.parse(t, !0); if (e.hostname && (!e.protocol || _r.indexOf(e.protocol) >= 0)) try { e.hostname = br.toUnicode(e.hostname) } catch { } return me.decode(me.format(e), me.decode.defaultChars + "%") } function J(t, e) { if (!(this instanceof J)) return new J(t, e); e || Re.isString(t) || (e = t || {}, t = "default"), this.inline = new wi, this.block = new xi, this.core = new ki, this.renderer = new _i, this.linkify = new yi, this.validateLink = Ci, this.normalizeLink = qi, this.normalizeLinkText = Si, this.utils = Re, this.helpers = Re.assign({}, bi), this.options = {}, this.configure(t), e && this.set(e) } J.prototype.set = function (t) { return Re.assign(this.options, t), this }, J.prototype.configure = function (t) { var e = this, n; if (Re.isString(t) && (n = t, t = vi[n], !t)) throw new Error('Wrong `markdown-it` preset "' + n + '", check name'); if (!t) throw new Error("Wrong `markdown-it` preset, can't be empty"); return t.options && e.set(t.options), t.components && Object.keys(t.components).forEach(function (r) { t.components[r].rules && e[r].ruler.enableOnly(t.components[r].rules), t.components[r].rules2 && e[r].ruler2.enableOnly(t.components[r].rules2) }), this }, J.prototype.enable = function (t, e) { var n = []; Array.isArray(t) || (t = [t]), ["core", "block", "inline"].forEach(function (o) { n = n.concat(this[o].ruler.enable(t, !0)) }, this), n = n.concat(this.inline.ruler2.enable(t, !0)); var r = t.filter(function (o) { return n.indexOf(o) < 0 }); if (r.length && !e) throw new Error("MarkdownIt. Failed to enable unknown rule(s): " + r); return this }, J.prototype.disable = function (t, e) { var n = []; Array.isArray(t) || (t = [t]), ["core", "block", "inline"].forEach(function (o) { n = n.concat(this[o].ruler.disable(t, !0)) }, this), n = n.concat(this.inline.ruler2.disable(t, !0)); var r = t.filter(function (o) { return n.indexOf(o) < 0 }); if (r.length && !e) throw new Error("MarkdownIt. Failed to disable unknown rule(s): " + r); return this }, J.prototype.use = function (t) { var e = [this].concat(Array.prototype.slice.call(arguments, 1)); return t.apply(t, e), this }, J.prototype.parse = function (t, e) { if (typeof t != "string") throw new Error("Input data should be a String"); var n = new this.core.State(t, this, e); return this.core.process(n), n.tokens }, J.prototype.render = function (t, e) { return e = e || {}, this.renderer.render(this.parse(t, e), this.options, e) }, J.prototype.parseInline = function (t, e) { var n = new this.core.State(t, this, e); return n.inlineMode = !0, this.core.process(n), n.tokens }, J.prototype.renderInline = function (t, e) { return e = e || {}, this.renderer.render(this.parseInline(t, e), this.options, e) }; var Di = J, Ti = Di; const Ri = Pt(Ti); var Ni = p.defineComponent({ name: "VueMarkdown", props: { source: { type: String, required: !0 }, options: { type: Object, required: !1 } }, data: function () { return { md: null } }, computed: { content: function () { var t, e = this.source; return (t = this.md) === null || t === void 0 ? void 0 : t.render(e) } }, created: function () { var t; this.md = new Ri((t = this.options) !== null && t !== void 0 ? t : {}) }, render: function () { return p.h("div", { innerHTML: this.content }) } }); const Li = Ni, Bt = p.defineComponent({ __name: "Message", props: { message: { type: Object, required: !0 } }, setup(t) { const e = t, { message: n } = p.toRefs(e), r = p.computed(() => n.value.text || "&lt;Empty response&gt;"), o = p.computed(() => ({ "chat-message-from-user": n.value.sender === "user", "chat-message-from-bot": n.value.sender === "bot" })), s = { highlight(i, c) { if (c && Ie.getLanguage(c)) try { return Ie.highlight(i, { language: c }).value } catch { } return "" } }; return (i, c) => (p.openBlock(), p.createElementBlock("div", { class: p.normalizeClass(["chat-message", o.value]) }, [p.renderSlot(i.$slots, "default", {}, () => [p.createVNode(p.unref(Li), { class: "chat-message-markdown", source: r.value, options: s }, null, 8, ["source"])])], 2)) } }), Bi = p.createElementVNode("div", { class: "chat-message-typing-body" }, [p.createElementVNode("span", { class: "chat-message-typing-circle" }), p.createElementVNode("span", { class: "chat-message-typing-circle" }), p.createElementVNode("span", { class: "chat-message-typing-circle" })], -1), Mi = p.defineComponent({ __name: "MessageTyping", props: { animation: { type: String, default: "bouncing" } }, setup(t) { const e = t, n = { id: "typing", text: "", sender: "bot", createdAt: "" }, r = p.computed(() => ({ "chat-message-typing": !0, [`chat-message-typing-animation-${e.animation}`]: !0 })); return (o, s) => (p.openBlock(), p.createBlock(p.unref(Bt), { class: p.normalizeClass(r.value), message: n }, { default: p.withCtx(() => [Bi]), _: 1 }, 8, ["class"])) } }), Ii = { class: "chat-messages-list" }, Oi = p.defineComponent({ __name: "MessagesList", props: { messages: { type: Array, required: !0 } }, setup(t) { const e = it(), { initialMessages: n, waitingForResponse: r } = e; return (o, s) => (p.openBlock(), p.createElementBlock("div", Ii, [(p.openBlock(!0), p.createElementBlock(p.Fragment, null, p.renderList(p.unref(n), i => (p.openBlock(), p.createBlock(Bt, { key: i.id, message: i }, null, 8, ["message"]))), 128)), (p.openBlock(!0), p.createElementBlock(p.Fragment, null, p.renderList(t.messages, i => (p.openBlock(), p.createBlock(Bt, { key: i.id, message: i }, null, 8, ["message"]))), 128)), p.unref(r) ? (p.openBlock(), p.createBlock(Mi, { key: 0 })) : p.createCommentVNode("", !0)])) } }), Fi = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" }, Pi = [p.createElementVNode("path", { fill: "currentColor", d: "m2 21l21-9L2 3v7l15 2l-15 2z" }, null, -1)]; function zi(t, e) { return p.openBlock(), p.createElementBlock("svg", Fi, [...Pi]) } const Ui = { name: "mdi-send", render: zi }, Vi = { class: "chat-input" }, $i = ["placeholder", "onKeydown"], Gi = ["disabled"], Hi = p.defineComponent({ __name: "Input", setup(t) { const e = it(), { waitingForResponse: n } = e, { t: r } = Oe(), o = p.ref(""), s = p.computed(() => o.value === "" || n.value); async function i(a) { if (a.preventDefault(), s.value) return; const l = o.value; o.value = "", await e.sendMessage(l) } async function c(a) { a.shiftKey || await i(a) } return (a, l) => (p.openBlock(), p.createElementBlock("div", Vi, [p.withDirectives(p.createElementVNode("textarea", { "onUpdate:modelValue": l[0] || (l[0] = u => o.value = u), rows: "1", placeholder: p.unref(r)("inputPlaceholder"), onKeydown: p.withKeys(c, ["enter"]) }, null, 40, $i), [[p.vModelText, o.value]]), p.createElementVNode("button", { disabled: s.value, class: "chat-input-send-button", onClick: i }, [p.createVNode(p.unref(Ui), { height: "32", width: "32" })], 8, Gi)])) } }), kr = p.defineComponent({ __name: "Chat", setup(t) { const { t: e } = Oe(), n = it(), { messages: r, currentSessionId: o } = n, { options: s } = at(); async function i() { n.startNewSession(), p.nextTick(() => { he.emit("scrollToBottom") }) } async function c() { await n.loadPreviousSession(), p.nextTick(() => { he.emit("scrollToBottom") }) } return p.onMounted(async () => { await c(), !s.showWelcomeScreen && !o.value && await i() }), (a, l) => (p.openBlock(), p.createBlock(Oo, { class: "chat-wrapper" }, { header: p.withCtx(() => [p.createElementVNode("h1", null, p.toDisplayString(p.unref(e)("title")), 1), p.createElementVNode("p", null, p.toDisplayString(p.unref(e)("subtitle")), 1)]), footer: p.withCtx(() => [p.unref(o) ? (p.openBlock(), p.createBlock(Hi, { key: 0 })) : (p.openBlock(), p.createBlock(Wo, { key: 1 }))]), default: p.withCtx(() => [!p.unref(o) && p.unref(s).showWelcomeScreen ? (p.openBlock(), p.createBlock(zo, { key: 0, "onClick:button": i })) : (p.openBlock(), p.createBlock(Oi, { key: 1, messages: p.unref(r) }, null, 8, ["messages"]))]), _: 1 })) } }), ji = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" }, Zi = [p.createElementVNode("path", { fill: "currentColor", d: "M12 3c5.5 0 10 3.58 10 8s-4.5 8-10 8c-1.24 0-2.43-.18-3.53-.5C5.55 21 2 21 2 21c2.33-2.33 2.7-3.9 2.75-4.5C3.05 15.07 2 13.13 2 11c0-4.42 4.5-8 10-8" }, null, -1)]; function Wi(t, e) { return p.openBlock(), p.createElementBlock("svg", ji, [...Zi]) } const Ki = { name: "mdi-chat", render: Wi }, Ji = { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em" }, Yi = [p.createElementVNode("path", { fill: "currentColor", d: "M7.41 8.58L12 13.17l4.59-4.59L18 10l-6 6l-6-6z" }, null, -1)]; function Xi(t, e) { return p.openBlock(), p.createElementBlock("svg", Ji, [...Yi]) } const Qi = { name: "mdi-chevron-down", render: Xi }, ea = { class: "chat-window-wrapper" }, ta = { class: "chat-window" }, na = p.defineComponent({ __name: "ChatWindow", setup(t) { const e = p.ref(!1); function n() { e.value = !e.value, e.value && p.nextTick(() => { he.emit("scrollToBottom") }) } return (r, o) => (p.openBlock(), p.createElementBlock("div", ea, [p.createVNode(p.Transition, { name: "chat-window-transition" }, { default: p.withCtx(() => [p.withDirectives(p.createElementVNode("div", ta, [p.createVNode(kr)], 512), [[p.vShow, e.value]])]), _: 1 }), p.createElementVNode("div", { class: "chat-window-toggle", onClick: n }, [p.createVNode(p.Transition, { name: "chat-window-toggle-transition", mode: "out-in" }, { default: p.withCtx(() => [e.value ? (p.openBlock(), p.createBlock(p.unref(Qi), { key: 1, height: "32", width: "32" })) : (p.openBlock(), p.createBlock(p.unref(Ki), { key: 0, height: "32", width: "32" }))]), _: 1 })])])) } }), ra = p.defineComponent({ __name: "App", props: {}, setup(t) { const { options: e } = at(), n = p.computed(() => e.mode === "fullscreen"); return p.onMounted(() => { Ie.registerLanguage("xml", yo), Ie.registerLanguage("javascript", qo) }), (r, o) => n.value ? (p.openBlock(), p.createBlock(p.unref(kr), { key: 0, class: "n8n-chat" })) : (p.openBlock(), p.createBlock(p.unref(na), { key: 1, class: "n8n-chat" })) } }); var Xe, oa = new Uint8Array(16); function sa() { if (!Xe && (Xe = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto < "u" && typeof msCrypto.getRandomValues == "function" && msCrypto.getRandomValues.bind(msCrypto), !Xe)) throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported"); return Xe(oa) } const ca = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i; function ia(t) { return typeof t == "string" && ca.test(t) } for (var $ = [], Mt = 0; Mt < 256; ++Mt)$.push((Mt + 256).toString(16).substr(1)); function aa(t) { var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, n = ($[t[e + 0]] + $[t[e + 1]] + $[t[e + 2]] + $[t[e + 3]] + "-" + $[t[e + 4]] + $[t[e + 5]] + "-" + $[t[e + 6]] + $[t[e + 7]] + "-" + $[t[e + 8]] + $[t[e + 9]] + "-" + $[t[e + 10]] + $[t[e + 11]] + $[t[e + 12]] + $[t[e + 13]] + $[t[e + 14]] + $[t[e + 15]]).toLowerCase(); if (!ia(n)) throw TypeError("Stringified UUID is invalid"); return n } function Ne(t, e, n) { t = t || {}; var r = t.random || (t.rng || sa)(); if (r[6] = r[6] & 15 | 64, r[8] = r[8] & 63 | 128, e) { n = n || 0; for (var o = 0; o < 16; ++o)e[n + o] = r[o]; return e } return aa(r) } async function la() { return "" } async function xr(...t) { var r; const e = await la(); return await (await fetch(t[0], { ...t[1], mode: "cors", cache: "no-cache", headers: { "Content-Type": "application/json", ...e ? { authorization: `Bearer ${e}` } : {}, ...(r = t[1]) == null ? void 0 : r.headers } })).json() } async function wr(t, e = {}, n = {}) { let r = t; return Object.keys(e).length > 0 && (r = `${r}?${new URLSearchParams(e).toString()}`), await xr(r, { ...n, method: "GET" }) } async function yr(t, e = {}, n = {}) { return await xr(t, { ...n, method: "POST", body: JSON.stringify(e) }) } async function ua(t, e) { var r, o; return await (((r = e.webhookConfig) == null ? void 0 : r.method) === "POST" ? yr : wr)(`${e.webhookUrl}`, { action: "loadPreviousSession", [e.chatSessionKey]: t, ...e.metadata ? { metadata: e.metadata } : {} }, { headers: (o = e.webhookConfig) == null ? void 0 : o.headers }) } async function pa(t, e, n) { var o, s; return await (((o = n.webhookConfig) == null ? void 0 : o.method) === "POST" ? yr : wr)(`${n.webhookUrl}`, { action: "sendMessage", [n.chatSessionKey]: e, [n.chatInputKey]: t, ...n.metadata ? { metadata: n.metadata } : {} }, { headers: (s = n.webhookConfig) == null ? void 0 : s.headers }) } const fa = { install(t, e) { t.provide(hn, e); const n = p.ref([]), r = p.ref(null), o = p.ref(!1), s = p.computed(() => (e.initialMessages ?? []).map(u => ({ id: Ne(), text: u, sender: "bot", createdAt: new Date().toISOString() }))); async function i(u) { const d = { id: Ne(), text: u, sender: "user", createdAt: new Date().toISOString() }; n.value.push(d), o.value = !0, p.nextTick(() => { he.emit("scrollToBottom") }); const f = await pa(u, r.value, e); let h = f.output ?? f.text ?? ""; if (h === "" && Object.keys(f).length > 0) try { h = JSON.stringify(f, null, 2) } catch { } const m = { id: Ne(), text: h, sender: "bot", createdAt: new Date().toISOString() }; n.value.push(m), o.value = !1, p.nextTick(() => { he.emit("scrollToBottom") }) } async function c() { if (!e.loadPreviousSession) return; const u = localStorage.getItem(pn) ?? Ne(), d = await ua(u, e), f = new Date().toISOString(); return n.value = ((d == null ? void 0 : d.data) || []).map((h, m) => ({ id: `${m}`, text: h.kwargs.content, sender: h.id.includes("HumanMessage") ? "user" : "bot", createdAt: f })), n.value.length && (r.value = u), u } async function a() { r.value = Ne(), localStorage.setItem(pn, r.value) } const l = { initialMessages: s, messages: n, currentSessionId: r, waitingForResponse: o, loadPreviousSession: c, startNewSession: a, sendMessage: i }; t.provide(fn, l), t.config.globalProperties.$chat = l } }; function ha(t) { var o, s; const e = { ...qe, ...t, webhookConfig: { ...qe.webhookConfig, ...t == null ? void 0 : t.webhookConfig }, i18n: { ...qe.i18n, ...t == null ? void 0 : t.i18n, en: { ...(o = qe.i18n) == null ? void 0 : o.en, ...(s = t == null ? void 0 : t.i18n) == null ? void 0 : s.en } }, theme: { ...qe.theme, ...t == null ? void 0 : t.theme } }, n = e.target ?? Fo; typeof n == "string" && Lo(n); const r = p.createApp(ra); return r.use(fa, e), r.mount(n), r } ue.createChat = ha, Object.defineProperty(ue, Symbol.toStringTag, { value: "Module" })
});
